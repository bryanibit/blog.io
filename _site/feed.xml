<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>屋顶上的鱼</title>
    <description>于华超</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 02 Oct 2018 11:38:31 +0800</pubDate>
    <lastBuildDate>Tue, 02 Oct 2018 11:38:31 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Daily Plan</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Add &lt;strong&gt;github star repo&lt;/strong&gt; to plan!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;模仿gridmap_octomap–&amp;gt;interactivepc将octomap投影到nav_msgs/occupancy&lt;/p&gt;

&lt;h1 id=&quot;2018-7-第一个周&quot;&gt;2018-7 第一个周&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;搞懂ETHZ的gird map和运行Autoware效果,读几篇Hibert maps相关文章
boost::bind(), git submodule, ros::Time(0), ros::WallTime(0), 多线程相机驱动的关闭问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-2-1&quot;&gt;2018-7-2 :+1:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：查看关于grid地图的多种方法，读一篇文献&lt;/li&gt;
  &lt;li&gt;下午：看公开课，完成一周（第8周）的内容，并做笔记&lt;/li&gt;
  &lt;li&gt;晚上：树mei派安装gitlab + download所有的依赖for工作站（到8：00～8：30） + 运动&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-3-tada&quot;&gt;2018-7-3 :tada:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：读完grid_map的论文，共22页&lt;/li&gt;
  &lt;li&gt;下午：看公开课，看到第九周的内容&lt;/li&gt;
  &lt;li&gt;晚上：读一篇英文小说，傲慢与偏见20分钟，对下午没有看完的第九周课程，继续看一下&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-4-rocket&quot;&gt;2018-7-4 :rocket:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：查看gridmap的readme，使用gridmap运行包中的pointcloud数据&lt;/li&gt;
  &lt;li&gt;下午：查看elevation_map的代码&lt;/li&gt;
  &lt;li&gt;晚上：读一篇英文小说，傲慢与偏见20分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-5-metal&quot;&gt;2018-7-5 :metal:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：抛弃elevation_map，查看volumetric_map和grid_map直接绘制地图的可能性&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：公开课完成第9周前两节课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-6-octocat&quot;&gt;2018-7-6 :octocat:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：不使用octomap，直接使用gridmap，尝试pointcloud&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：空&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2018-7-第二个周&quot;&gt;2018-7 第二个周&lt;/h1&gt;

&lt;h2 id=&quot;2018-7-9--camel&quot;&gt;2018-7-9  :camel:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：完成RCS建构搭建&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：看公开课第九周&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-10--sparkles&quot;&gt;2018-7-10  :sparkles:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：安装新电脑&lt;/li&gt;
  &lt;li&gt;下午：集成浙大slam代码&lt;/li&gt;
  &lt;li&gt;晚上：公开课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-11&quot;&gt;2018-7-11&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：docker-gitlab端口映射的搭建&lt;/li&gt;
  &lt;li&gt;下午：同上，验收激光雷达&lt;/li&gt;
  &lt;li&gt;晚上：docker搭建验收&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-12&quot;&gt;2018-7-12&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：修改Yaowen的ANS模块&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：公开课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-13&quot;&gt;2018-7-13&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：修改ANS模块，现在将nml改完了，明天要改cfg，并用diag_NB工具调试&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：聚餐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-14&quot;&gt;2018-7-14&lt;/h2&gt;

&lt;p&gt;:octocat: 确认新的模块是可以运行的&lt;/p&gt;

&lt;p&gt;bryan/ANS_test是push到git的模块; 桌面hee是由基于master修改的ans和原来的zt; bryan里面的hee-originalverson是没有修改的ans（没有加入sjdw-module的）和原来的zt&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上午：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-18&quot;&gt;2018-7-18&lt;/h2&gt;

&lt;p&gt;git中origin master（branch）和 working space 暂存区的区别，commit是到分支上而暂存区是每个分支共有吗？&lt;/p&gt;

&lt;p&gt;看代码rcslib源码，传递long型的效果&lt;/p&gt;

&lt;p&gt;/etc/modprode   /dev/rule.d&lt;/p&gt;

&lt;p&gt;办理电脑入网，打电话给王申&lt;/p&gt;

&lt;p&gt;询问张凯路径重规划的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上午：抽一会儿看一下线程的概念&lt;/li&gt;
  &lt;li&gt;下午：今天任务大约完成&lt;/li&gt;
  &lt;li&gt;晚上：English&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;we will stick to the strictest definition in the interest of clarity.&lt;/p&gt;

&lt;p&gt;go to the horse’s mouth&lt;/p&gt;

&lt;p&gt;属性图-概率图  场景建模模块 加个通道，
64线，读32线，三张图，同样的消息类型&lt;/p&gt;

&lt;h2 id=&quot;2018-7-31&quot;&gt;2018-7-31&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Merge code to track_uvc from dev_zjd&lt;/li&gt;
  &lt;li&gt;采集数据&lt;/li&gt;
  &lt;li&gt;激光标定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;国庆9天&quot;&gt;国庆9天&lt;/h2&gt;

&lt;p&gt;:camel: 多完成的加以备注&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;9-29&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective c++ 第一章（笔记blog）&lt;/li&gt;
  &lt;li&gt;the giver 20th 21st&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;9-30&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective c++ 第二章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(函数式编程，面向对象编程，面向对象高级编程)(笔记blog)&lt;/li&gt;
  &lt;li&gt;the giver 22th and the left&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-1&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a rest&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-2&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a rest&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-3&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第三章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(错误调试，IO编程)&lt;/li&gt;
  &lt;li&gt;Mindset 10 to 20 pages&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-4&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a test&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-5&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第四章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(进程和线程，正则表达式)&lt;/li&gt;
  &lt;li&gt;Mindset 10 to 20 pages&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-6&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第五章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(内建模块)&lt;/li&gt;
  &lt;li&gt;Mindset 10 to 20 pages&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-7&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第六章&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;liaoxuefeng python(异步IO，常用第三方模块)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mindset 10 to 20 pages&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-8&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Go to work&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/10/02/daily-plan/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/10/02/daily-plan/</guid>
        
        <category>个人总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Effective C++</title>
        <description>&lt;h1 id=&quot;1-template-type-deduce&quot;&gt;1. template type deduce&lt;/h1&gt;

&lt;p&gt;The behaviour and purpose&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(ParamType param);
f(expr); // deduce T and ParamType from expr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-referencepointer-之-lvalue-reference&quot;&gt;by-reference/pointer 之 lvalue-reference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;by-reference said &lt;em&gt;const int&lt;/em&gt; is different from &lt;em&gt;int&lt;/em&gt;. To be honest, both are different anywhere.&lt;/li&gt;
  &lt;li&gt;If expr’s type is a reference, ignore the reference part.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param); // param is a reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is int&amp;amp;
f(cx); // T is const int, param's type is const int&amp;amp;
f(rx); // T is const int, param's type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param); // param is a const reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is const int&amp;amp;
f(cx); // T is int, param's type is const int&amp;amp;
f(rx); // T is int, param's type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T* param); // param is a pointer
int x = 27; // x is an int
const int *cx = &amp;amp;x; // cx is a const int *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(&amp;amp;x); // T is int, param's type is int*
f(px); // T is const int, param's type is const int*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-reference-之-universal-reference&quot;&gt;by-reference 之 universal-reference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If &lt;em&gt;expr&lt;/em&gt; is an lvalue, both T and ParamType are deduced to be lvalue references.&lt;strong&gt;it’s the only situation in template type deduction where T is deduced to be a reference.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;If expr is an rvalue, the “normal” (i.e., the above Case 1) rules apply.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param); // param is a universal reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int&amp;amp;, param's type is int&amp;amp;
f(cx); // T is const int&amp;amp;, param's type is const int&amp;amp;
f(rx); // T is const int&amp;amp;, param's type is const int&amp;amp;
f(32); // 32 is rvalue, T is int, param's type is int&amp;amp;&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-value&quot;&gt;by-value&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;if expr’s type is a reference, ignore the reference part.&lt;/li&gt;
  &lt;li&gt;if expr is const, ignore that, too. If it’s volatile, also ignore that&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T param); // param is now pass by value
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is int
f(cx); // T is int, param's type is int
f(rx); // T is int, param's type is int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is because param is an object that’s completely independent of cx and rx—a copy of cx or rx. The fact that cx and rx can’t be modified says nothing about whether param can be. That’s why expr’s constness (and volatileness, if any) is ignored when deducing a type for param.&lt;/p&gt;

&lt;h3 id=&quot;array-arguments&quot;&gt;Array Arguments&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const char name[] = &quot;J. P. Briggs&quot;;
const char * ptrToName = name;
template&amp;lt;typename T&amp;gt;
void f(T param); // template with by-value parameter
f(name); // T is deduced to const char *, param is the same.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the above is changed to:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param); // template with by-reference parameter
f(name); // T is deduced to const char [13], param is const char (&amp;amp;) [13]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;return size of an array as a compile-time constant.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T, std::size_t N&amp;gt;
constexpr std::size_t arraySize(**T (&amp;amp;) [N]**) noexcept //result availble during compilation
{
	return N;
}
int keyvals [] = {1,2,3,4,5,6,7};
int mapvals [arraySize(keyvals)];
std::array&amp;lt;int, arraySize(keyVals)&amp;gt; mappedVals;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;function-arguments&quot;&gt;Function Arguments&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void someFunc(int, double); // someFunc is a function; type is void(int, double)
template&amp;lt;typename T&amp;gt;
void f1(T param); // in f1, param passed by value
template&amp;lt;typename T&amp;gt;
void f2(T&amp;amp; param); // in f2, param passed by ref
f1(someFunc); // param deduced as ptr-to-func; type is void (*)(int, double)
f2(someFunc); // param deduced as ref-to-func; type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Things to Remember
• During template type deduction, arguments that are references are treated as
non-references, i.e., their reference-ness is ignored.
• When deducing types for universal reference parameters, lvalue arguments get
special treatment.
• When deducing types for by-value parameters, const and/or volatile argu‐
ments are treated as non-const and non-volatile.
• During template type deduction, arguments that are array or function names
decay to pointers, unless they’re used to initialize references.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-auto-type-deduction&quot;&gt;2. auto type deduction&lt;/h1&gt;

&lt;h2 id=&quot;same-with-template-type-deduction&quot;&gt;Same with template type deduction&lt;/h2&gt;

&lt;p&gt;When a variable is declared using &lt;em&gt;auto&lt;/em&gt;, auto plays the role of &lt;strong&gt;T&lt;/strong&gt; in the template, and
the type specifier for the variable acts as &lt;em&gt;ParamType&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------------lvalue reference-------------
auto x = 27; //auto is deducted to int, x is int
const auto cx = x; //auto is deducted to int, cx is const int
const auto&amp;amp; rx = x; // auto is deducted to int, rx is const int&amp;amp;
--------------universal reference--------
auto&amp;amp;&amp;amp; uref1 = x; // x is int and lvalue, so uref1's type is int&amp;amp;
auto&amp;amp;&amp;amp; uref2 = cx; // cx is const int and lvalue, so uref2's type is const int&amp;amp;
auto&amp;amp;&amp;amp; uref3 = 27; // 27 is rvalue, so uref3's type is int&amp;amp;&amp;amp;
const char name[] = // name's type is const char[13]
----------array and function-------------
&quot;R. N. Briggs&quot;;
auto arr1 = name; // arr1's type is const char*
auto&amp;amp; arr2 = name; // arr2's type is const char (&amp;amp;)[13]
void someFunc(int, double); // someFunc is a function; type is void(int, double)
auto func1 = someFunc; // func1's type is void (*)(int, double)
auto&amp;amp; func2 = someFunc; // func2's type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The template type deduction is the same with the auto type deduction. They are essentially
two sides of the same coin. Except for the one way they differ.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int x1 = 27;
int x2(27);
int x3 = {27};
int x4{27}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above is the same in c++11 to one result: an int with value 27. And use &lt;em&gt;auto&lt;/em&gt; to replace the above &lt;em&gt;int&lt;/em&gt;.
Then the first two is ditto and the last two ones become &lt;code class=&quot;highlighter-rouge&quot;&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;. The treatment of braced(means {}) initializers is the only way in which auto type deduction and template type deduction differ. So the only real difference between auto and template type deduction is that auto assumes that a braced initializer represents a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::initializer_list&lt;/code&gt;, but template type deduction doesn’t. The evidence is shown the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
void f(T param);
f({1,2,3}); // fail
template &amp;lt;typename T&amp;gt;
void f(std::initializer_list&amp;lt;T&amp;gt; param);
f({1,2,3}); // OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In C++14, the tale continues. C++14 permits auto to indicate that a function’s return type should be deduced, and
C++14 lambdas may use auto in parameter declarations.
auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.&lt;/p&gt;

&lt;h1 id=&quot;3-understand-decltype&quot;&gt;3. Understand decltype&lt;/h1&gt;

&lt;h2 id=&quot;decltype-type&quot;&gt;decltype type&lt;/h2&gt;

&lt;p&gt;decltype saves the original type of variable, no complex deduction.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Widget w;
const Widget&amp;amp; cw = w;
auto myWidget1 = cw; // auto type deduction(by-value): myWidget1's type is Widget
decltype(auto) myWidget2 = cw; // decltype type deduction: myWidget2's type is const Widget&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Just like the above &lt;code class=&quot;highlighter-rouge&quot;&gt;myWidget1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;myWidget2&lt;/code&gt;, the value of function returning can not be auto. If not, the reference and anyother things will diminish.&lt;/p&gt;

&lt;p&gt;In according to rvalue and lvalue, the function’s parameter becomes universal reference.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename Container, typename Index&amp;gt; // final
decltype(auto) 															 // C++14
authAndAccess(Container&amp;amp;&amp;amp; c, Index i) 			 // version
{
authenticateUser();
return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
--------------------------------------
template&amp;lt;typename Container, typename Index&amp;gt; // final
auto 																				 // C++11
authAndAccess(Container&amp;amp;&amp;amp; c, Index i) 			 // version
-&amp;gt; decltype(std::forward&amp;lt;Container&amp;gt;(c)[i])
{
authenticateUser();
return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-1&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Things to Remember
 • decltype almost always yields the type of a variable or expression without any modifications.
 • For lvalue expressions of type T other than names, decltype always reports a type of T&amp;amp;.
 • C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.
 • auto variables have their type deduced from their initializer,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;4-know-how-to-view-deduced-types&quot;&gt;4. Know how to view deduced types&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::type_info::name&lt;/code&gt; mandates that the type be treated as if it had been passed to a template
function as a by-value parameter. e.g.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::cout &amp;lt;&amp;lt; typeid(x).name() &amp;lt;&amp;lt; '\n'; // display types for
std::cout &amp;lt;&amp;lt; typeid(y).name() &amp;lt;&amp;lt; '\n'; // x and y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Boost TypeIndex library (often written as Boost.TypeIndex) is designed to succeed. And I don’t want to expand the content.&lt;/p&gt;

&lt;h1 id=&quot;5-prefer-auto-to-explicit-type-declarations&quot;&gt;5. Prefer auto to explicit type declarations&lt;/h1&gt;

&lt;p&gt;Here, we insert something irrelevant to &lt;em&gt;auto&lt;/em&gt;. It is how to reserve bidirectional iterators:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iterator&amp;gt;
template&amp;lt;class BidirIt&amp;gt;
void my_reverse(BidirIt first, BidirIt last)
{
    typename std::iterator_traits&amp;lt;BidirIt&amp;gt;::difference_type n = std::distance(first, last);//complete written
		//auto n = std::distance(first, last);//correct like ditto
    --n;
    while(n &amp;gt; 0) {
        typename std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type tmp = *first;//complete written
				//auto tmp = *first;//correct like ditto
        *(first++) = *(--last);
        *last = tmp;
        n -= 2;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;std::function&lt;/strong&gt; is a template in the C++11 Standard Library that &lt;em&gt;generalizes&lt;/em&gt; the idea of a function pointer. But you must specify the type of function(function signature) to refer to when you create a std::function object. the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::function&lt;/code&gt; approach is generally bigger and slower than the &lt;em&gt;auto&lt;/em&gt; approach, and it may yield out-of-memory exceptions, too.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v;
unsigned int n = v.size()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To be honest, the real returning type of &lt;code class=&quot;highlighter-rouge&quot;&gt;v.size()&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;int&amp;gt;::size_type&lt;/code&gt;. It is the same with &lt;em&gt;unsigned int&lt;/em&gt; on 32-bit, but different on 64-bit.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::unordered_map&amp;lt;std::string, int&amp;gt; m;
for(std::pair&amp;lt;std::string, int&amp;gt; &amp;amp;p: m){}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This seem perfectly reasonable. But std::unordered_map’s key is &lt;em&gt;const&lt;/em&gt;, so it it std::pair&amp;lt;const std::string, int&amp;gt;. That will result in a temporary object producing. Use auto: &lt;code class=&quot;highlighter-rouge&quot;&gt;for(const auto&amp;amp; p: m){}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The above examples show how	&lt;strong&gt;explicitly specifying&lt;/strong&gt; types can lead to &lt;strong&gt;implicit conversions&lt;/strong&gt; that you neither want nor expect. If you use &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt; as the type of the target variable, you need not worry about mismatches between the type of variable you’re declaring and the type of the expression used to initialize it.&lt;/p&gt;

&lt;h1 id=&quot;6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types&quot;&gt;6. Use the explicitly typed initializer idiom when auto deduces undesired types.&lt;/h1&gt;

&lt;p&gt;First of all, we see the example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Widget w;
bool highPriority = feature(w)[5]; //std::vector&amp;lt;bool&amp;gt; feature(Widget);
processWidget(w, highPriority);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The code is right, but we can change that to the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto highPriority = feature(w)[5];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[ ] return T&amp;amp;, auto here is deduced bool&amp;amp; as matter of course. But C++ is not empowered to use &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&amp;amp;&lt;/code&gt;. So &lt;em&gt;highPriority&lt;/em&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt;. One implementation is for such objects to contain a pointer to the machine word holding the referenced bit,
plus the offset into that word for that bit. So the above code has some problems: highPriority references the type function feature returns which is a temporay object and is reserved until the sentence “feature(w)[5] finishs.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is an example of a &lt;strong&gt;proxy class&lt;/strong&gt;: a class that exists for the purpose of emulating and augmenting the behavior of some other type. As a general rule, “invisible” proxy classes don’t play well with auto. The explicitly typed initializer idiom involves declaring a variable with auto, but casting the initialization expression to the type you want auto to deduce. The code above is modified like that:&lt;code class=&quot;highlighter-rouge&quot;&gt;auto highPriority = static_cast&amp;lt;bool&amp;gt;(features(w)[5]);&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-2&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• “Invisible” proxy types can cause auto to deduce the “wrong” type for an ini‐
tializing expression.
• The explicitly typed initializer idiom forces auto to deduce the type you want
it to have.
• Implicit type deduction is forbidden in C++11 and easy to result in undefined behaviour.
Sometimes, static_cast&amp;lt;&amp;gt; is adopted with auto.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/28/effective-cpp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/28/effective-cpp/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Cross Obstables</title>
        <description>&lt;p&gt;&lt;strong&gt;浮生如梦&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;all-in-all&quot;&gt;All in all&lt;/h2&gt;

&lt;p&gt;In words, control of the car is not accurate, planning of the car is not complete, and perspection of the car is not applicable.&lt;/p&gt;

&lt;p&gt;First of all, the control algorithm or excutive agencies may have latency problems which result from vehicle classis. And then, planning module lacks global planning, contains only local planning. The current methods of planning is solely suitable for closed road environment and not sparse RNDF. Both of them are missing in this game, so the game has not started but has finished. The failure is destined. Finally, the behavior of hitting trees is abnormal for UVCs, for which perspection of the car is responbible. It tells us that it is not sensible to depend on sole sensor giving up multi-sensor fusion. For detecting accessible areas of cars, which is so important that the car moving relys heavily on, at least two different sensors produce accessible areas. At the same time, different algorithms are used to the same sensors to realize different results. Multi-source sensors fusion results in sophisticated system integration. That makes us need more time to consume others’ algorithm. It proves that system integration is not a simple problem of “1+1”.&lt;/p&gt;

&lt;p&gt;When results of multi-source sensors conflict with each other, how to fuse them to unified and wonderful result better than unique sensor. Or we can do fusion to a deeper degree, for example, fuse lasers and cameras data and then do clustering or segmentation.&lt;/p&gt;

&lt;h2 id=&quot;in-future&quot;&gt;In future&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Add global planning module. Replace current text saving RNDF with GUI and third part API. The tool needs to manipulate map data quickly. Especially, it needs contain map mathcing for GPS points, such as QGIS.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I should be familar with Kalman Filter from functions in OpenCV. KF is useful in multi-frame detection and tracking.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final problem is Scene Understanding for UVCs. It may come true via fusing multi-cameras even add laser data. I have no thoughts for now.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/19/cross-obstacles/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/19/cross-obstacles/</guid>
        
        <category>个人总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Eigen LIB</title>
        <description>&lt;h2 id=&quot;transform&quot;&gt;Transform&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::Vector3f trans_vec_A;
//note that you have to create a Translation because multiplying a 
//Transform with a vector will _apply_ the transform to the vector
Eigen::Translation&amp;lt;float,3&amp;gt; translation_A(trans_vec_A);
Eigen::Quaternionf rotation_B;
Eigen::Quaternionf rotation_C;
Eigen::Quaternionf rotation_D;
Eigen::Vector3f trans_vec_E;
Eigen::Translation&amp;lt;float,3&amp;gt; translation_E(trans_vec_E);
Eigen::Transform&amp;lt;float,3,Affine&amp;gt; combined = 
      translation_A * rotation_B * rotation_C * rotation_D * translation_E;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;{Note that} &lt;code class=&quot;highlighter-rouge&quot;&gt;combined = A*B*C*D*E&lt;/code&gt;, so combined applied to a &lt;em&gt;vector v&lt;/em&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;combined*v = A*B*C*D*E*v = A*(B*(C*(D*(E*v))))&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 04 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/04/eigen-lib/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/04/eigen-lib/</guid>
        
        <category>理论梳理</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>YAML-CPP</title>
        <description>&lt;p&gt;##安装&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;github网站下载，编译成库文件&lt;/li&gt;
  &lt;li&gt;安装ros后就安装了yaml-cpp&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;读yaml文件&quot;&gt;读yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt; 
#include &amp;lt;string&amp;gt;
#include &quot;yaml-cpp/yaml.h&quot;
template&amp;lt;typename T&amp;gt;
void operator &amp;gt;&amp;gt; (const YAML::Node&amp;amp; node, T&amp;amp; i)  //最新的yaml-cpp 0.5取消了运算符&quot;&amp;gt;&amp;gt;&quot;，但是还是会有好多的旧代码
{
  i = node.as&amp;lt;T&amp;gt;();                              //依旧在使用，所以重载下&quot;&amp;gt;&amp;gt;&quot;运算符
}
void configure(const YAML::Node&amp;amp; node);
void nodePrint(const YAML::Node&amp;amp; node);
int main()
{
  YAML::Node config = YAML::LoadFile(&quot;../monsters.yaml&quot;);  
  configure(config[&quot;Ladybug&quot;]);
  return 0;
}
void configure(const YAML::Node&amp;amp; node)
{
  std::cout &amp;lt;&amp;lt; &quot;node size is &quot; &amp;lt;&amp;lt; node.size() &amp;lt;&amp;lt; std::endl;
  for (unsigned int i = 0; i &amp;lt; node.size(); i++)
  {
    nodePrint(node[i]);
  }
}
void nodePrint(const YAML::Node&amp;amp; node)
{
  int name;
  int topic;
  string timeout;
  double priority;
  node[&quot;showImage&quot;]       &amp;gt;&amp;gt; name;
  node[&quot;saveImage&quot;]      &amp;gt;&amp;gt; topic;
  node[&quot;savePath&quot;]    &amp;gt;&amp;gt; timeout;
  node[&quot;resize&quot;]   &amp;gt;&amp;gt; priority;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;yaml文件&quot;&gt;yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# yaml for ladybug and rcs
Ladybug:
  - showImage:   1
    saveImage:   1
    savePath:    &quot;../filename&quot;
    resize:      1.0
    truncateBottom:    0.1
    truncateTop:    0.1
DetectArea:
  - radius:      6.0
    speed:       2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;写yaml文件&quot;&gt;写yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginSeq;
out &amp;lt;&amp;lt; &quot;eggs&quot;;
out &amp;lt;&amp;lt; &quot;bread&quot;;
out &amp;lt;&amp;lt; &quot;milk&quot;;
out &amp;lt;&amp;lt; YAML::EndSeq;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- eggs
- bread
- milk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;=========================&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginMap;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;name&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;Ryan Braun&quot;;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;position&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;LF&quot;;
out &amp;lt;&amp;lt; YAML::EndMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name: Ryan Braun
position: LF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;=========================&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginMap;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;name&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;Barack Obama&quot;;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;children&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; YAML::BeginSeq &amp;lt;&amp;lt; &quot;Sasha&quot; &amp;lt;&amp;lt; &quot;Malia&quot; &amp;lt;&amp;lt; YAML::EndSeq;
out &amp;lt;&amp;lt; YAML::EndMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name: Barack Obama
children:
  - Sasha
  - Malia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;==========================&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/08/26/yaml-cpp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/08/26/yaml-cpp/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Miscellaneous杂记</title>
        <description>&lt;h2 id=&quot;小岛经济学&quot;&gt;小岛经济学&lt;/h2&gt;

&lt;p&gt;没有自由的失败，就没有自由的成功&lt;/p&gt;

&lt;h2 id=&quot;effective-modern-c&quot;&gt;Effective Modern C++&lt;/h2&gt;

&lt;p&gt;It’s been said that the truth shall set you free, but under the right circumstances, a well-chose lie can be equally liberating. We comprise “lie” to abstraction.&lt;/p&gt;

&lt;p&gt;Bear in mind that the truth doesn’t make the abstraction any less useful.&lt;/p&gt;

&lt;p&gt;In short, rvalue reference should be &lt;em&gt;unconditionally&lt;/em&gt; cast to rvalue (via &lt;strong&gt;std::move&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Universal refenrence should be &lt;em&gt;conditionally&lt;/em&gt; cast to rvalue (via &lt;strong&gt;std::forward&lt;/strong&gt;).&lt;/p&gt;

&lt;h2 id=&quot;外汇管理局新规2016&quot;&gt;外汇管理局新规2016&lt;/h2&gt;

&lt;p&gt;根据外管局最新规定：&lt;a href=&quot;https://xueqiu.com/5514474822/66337756&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5个以上不同个人，同日、隔日或连续多日分别购汇后，将外汇汇给境外同一个人或机构；&lt;/li&gt;
  &lt;li&gt;个人在7日内从同一外汇储蓄账户5次以上提取接近等值1万美元外币现钞；&lt;/li&gt;
  &lt;li&gt;同一个人将其外汇储蓄账户内存款划转至5个以上直系亲属等情况。
将被界定为个人分拆结售汇行为，也就是俗称的“蚂蚁搬家”，一律进入黑名单，违规者将被剥夺两年合计10万美元的换汇额度。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;活着&quot;&gt;活着&lt;/h2&gt;

&lt;p&gt;内心使他真正地了解自己，了解了自己也就了解了世界。&lt;/p&gt;

&lt;h2 id=&quot;海盗经济学&quot;&gt;海盗经济学&lt;/h2&gt;

&lt;p&gt;海盗船实行的是民主（democracy），而商船实行的是专制（autocracy）；在海盗船上，甚至黑人（18th century)也能够享受和白人一样的权利，很少出现像商船那样，船长侮辱甚至殴打船员的现像，而且无论船长还是舵手和普通船员的工资差不多，没有商船上的差别那么悬殊。归结原因其实是&lt;em&gt;所有制&lt;/em&gt;导致了二者实行不同的管理制度，不同的管理制度保证了二者都有最大的总体利益，只是相对个人而言不甚相同。&lt;/p&gt;

&lt;h2 id=&quot;精通数据科学&quot;&gt;精通数据科学&lt;/h2&gt;
&lt;p&gt;The purpose of computing is insight, not numbers.
If you are immune to boredom, there is literally nothing you cannot accomplish. – David Foster Wallace&lt;/p&gt;

&lt;h2 id=&quot;effective-c&quot;&gt;Effective C++&lt;/h2&gt;
&lt;p&gt;I have not been able to find a convincing explanation. But the rule is the rule, and this means you must
remember that if you declare a variable using auto and you initialize it with a braced initializer, the deduced type will always be std::initializer_list. It’s especially important to bear this in mind if you embrace the philosophy of uniform initialization—of enclosing initializing values in braces &lt;strong&gt;as a matter of course(理所当然)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;It provides results that leave you scratching your head and turning to reference works or online Q&amp;amp;A sites for revelation.&lt;/p&gt;

&lt;p&gt;What may initially seem contradictory (decltype and auto?) actually makes perfect sense.&lt;/p&gt;

&lt;p&gt;Employing pass-by value for objects of &lt;strong&gt;an unknown type&lt;/strong&gt; generally risks the performance hit of unnecessary
copying, the behavioral problems of object slicing, and the sting of our coworkers’ derision.&lt;/p&gt;

&lt;p&gt;bring it into accord with admonition 使之符合告诫&lt;/p&gt;

&lt;p&gt;You’ll have to familiarize yourself with a few special cases. Most of these are too obscure to warrant discussion in a book like this, but looking at one lends insight into decltype as well as its use.&lt;/p&gt;

&lt;p&gt;At the same time, don’t lose sight of the bigger picture.&lt;/p&gt;

&lt;p&gt;I do my best to convice you to use lambdas instead of std::bind.&lt;/p&gt;

&lt;p&gt;Take a deep breath and relax. auto is a option, not a mandate.&lt;/p&gt;

&lt;p&gt;such abstract type information should almost always be at hand.&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/27/miscellaneous/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/27/miscellaneous/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>C++ 11/14/17</title>
        <description>&lt;h2 id=&quot;c-111417关键字&quot;&gt;C++ 11//14/17关键字&lt;/h2&gt;

&lt;h3 id=&quot;using关键字&quot;&gt;using关键字&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (*process)(void*);
using process = int(*)(void *);

using TrueDarkMagic = MagicType&amp;lt;std::vector&amp;lt;T&amp;gt;, std::string&amp;gt;;
TrueDarkMagic&amp;lt;bool&amp;gt; you;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BASE{
		public:
				int value1;
				int value2;
				BASE(){
						value1 = 1;
				}
				BASE(int value): BASE(){ //委托BASE()构造函数
						value2 = 2;
				}
};
class subBASE: public BASE{
		using BASE:BASE; //继承构造
};

int main(){
		subBASE s(3);
		std::cout &amp;lt;&amp;lt; s.value1&amp;lt;&amp;lt;s.value2&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;c111417标准库&quot;&gt;C++11/14/17标准库&lt;/h2&gt;

&lt;h3 id=&quot;stdarray&quot;&gt;std::array&lt;/h3&gt;

&lt;p&gt;std::array 保存在栈内存中，std::vector保存在堆内存。&lt;/p&gt;

&lt;p&gt;std::array 会在编译时创建一个固定大小的数组，std::array 不能够被&lt;em&gt;隐式&lt;/em&gt;的转换成指针。&lt;/p&gt;

&lt;p&gt;使用 std::array 很简单，只需指定其类型和大小即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::array&amp;lt;int, 4&amp;gt; arr= {1,2,3,4};
int len = 4;
std::array&amp;lt;int, len&amp;gt; arr = {1,2,3,4}; // *非法*, 数组大小参数必须是常量表达式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与C风格接口传参&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void foo(int *p, int len) {
    return;
}
std::array&amp;lt;int, 4&amp;gt; arr = {1,2,3,4}; //实例

// C 风格接口传参
// foo(arr, arr.size()); // *非法*, 无法隐式转换
foo(&amp;amp;arr[0], arr.size());
foo(arr.data(), arr.size()); //arr.data() return 指向arr的指针
// 使用 `std::sort`
std::sort(arr.begin(), arr.end());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;智能指针&quot;&gt;智能指针&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;智能指针实质是一个对象，行为表现的却像一个指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;引用计数不是垃圾回收，引用技术能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 &lt;memory&gt;。&lt;/memory&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而无需显示得调用 delete，当引用计数变为零的时候就会将对象自动删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;shared_ptr and unique_ptr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单个unique_ptr离开作用域时，会立即释放底层内存，既然是独占，换句话说就是不可复制;可以有多个shared_ptr实例指向同一块动态分配的内存，当最后一个shared_ptr离开作用域时，才会释放这块内存.&lt;/p&gt;

&lt;h3 id=&quot;c中正则表达式&quot;&gt;C++中正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查一个串是否包含某种形式的子串；&lt;/li&gt;
  &lt;li&gt;将匹配的子串替换；&lt;/li&gt;
  &lt;li&gt;从某个串中取出符合条件的子串。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;| &lt;strong&gt;特殊字符&lt;/strong&gt;  | &lt;strong&gt;描述&lt;/strong&gt; |
| :— | :—-: |
| $ | 匹配输入字符串的结尾位置 |
| (,) | 标记一个子表达式的开始和结束位置 |
|* | 匹配前面的子表达式零次或多次。
|+  | 匹配前面的子表达式一次或多次。
|. | 匹配除换行符 \n 之外的任何单字符。
————————————————–&lt;/p&gt;

&lt;h2 id=&quot;线程与并发&quot;&gt;线程与并发&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;最简单的是使用std::thread创建一个线程实例，这是并发编程的基础，需要包含&lt;thread&gt;头文件，其提供很多基本的线程操作：&lt;/thread&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;get_id()&lt;/em&gt; required ID of the created thead.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;join()&lt;/em&gt;  add one thread to pool.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\#include &amp;lt;iostream&amp;gt;
\#include &amp;lt;thread&amp;gt;
void foo()
{
    std::cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; std::endl;
}
int main()
{
    std::thread t(foo); //new one thread
    t.join(); //start the thread, the main funtion waits until the thread ends
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::mutex is the basic class in C++11, mutex variables can be created via instancing std::mutex. &lt;mutex&gt; needs to be included.&lt;/mutex&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;member funtion: lock() unlock()&lt;/p&gt;

&lt;p&gt;object: std::unique_lock&lt;std::mutex&gt; std::look_guard&lt;std::mutex&gt;&lt;/std::mutex&gt;&lt;/std::mutex&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;mutex&amp;gt;
std::mutex mtx;
void block_area() {
std::unique_lock&amp;lt;std::mutex&amp;gt; lock(mtx);
    //...临界区
lock.unlock();
    //...some other code
lock.lock(); //  can lock again
}
int main() {
    std::thread thd1(block_area);
    std::thread thd2(block_area);
    thd1.join(); //阻塞式，main等待线程接受后一并返回
    thd2.detach(); //放在后台执行，与main无关了
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::future, std::packaged_task&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;std::future提供了一个访问异步操作结果的途径，是一种简单的线程同步手段。&lt;/p&gt;

&lt;p&gt;std::packaged_task用来封装任何可以调用的目标，从而实现异步调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;future&amp;gt;
#include &amp;lt;thread&amp;gt;
int main()
{
    // 将一个返回值为7的 lambda 表达式封装到 task 中
    // std::packaged_task 的模板参数为要封装函数的类型
    std::packaged_task&amp;lt;int()&amp;gt; task([](){return 7;});
    // 获得 task 的 future
    std::future&amp;lt;int&amp;gt; result = task.get_future(); // 在一个线程中执行 task
    std::thread(std::move(task)).detach(); std::cout &amp;lt;&amp;lt; &quot;Waiting...&quot;;
    result.wait();
    // 输出执行结果
    std::cout &amp;lt;&amp;lt; &quot;Done!&quot; &amp;lt;&amp;lt; std:: endl &amp;lt;&amp;lt; &quot;Result is &quot; &amp;lt;&amp;lt; result.get() &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::condition_variable&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。&lt;/p&gt;

&lt;h2 id=&quot;参数包&quot;&gt;参数包&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;模板参数包&lt;/strong&gt;是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数模板形参报是接受零或更多函数实参的函数形参。&lt;/p&gt;

&lt;p&gt;参考的链接：&lt;a href=&quot;https://www.cnblogs.com/qicosmos/p/4325949.html&quot;&gt;泛化之美&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至少有一个参数包的模板被称作&lt;strong&gt;变参数模板&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面这种情况是&lt;em&gt;类模板&lt;/em&gt;（变参数类模板可用任意数量的模板参数实例化）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;class ... Types&amp;gt; struct Tuple {};
Tuple&amp;lt;&amp;gt; t0;           // Types 不包含实参
Tuple&amp;lt;int&amp;gt; t1;        // Types 包含一个实参： int
Tuple&amp;lt;int, float&amp;gt; t2; // Types 包含二个实参： int 与 float
Tuple&amp;lt;0&amp;gt; error;       // 错误： 0 不是类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面这种情况是&lt;em&gt;函数模板&lt;/em&gt;(变参数函数模板可用任意数量的函数实参调用{&lt;strong&gt;模板参数通过模板实参推导推导&lt;/strong&gt;}）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;class ... Types&amp;gt; void f(Types ... args);
f();       // OK ： args 不包含实参
f(1);      // OK ： args 包含一个实参： int
f(2, 1.0); // OK ： args 包含二个实参： int 与 double
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在初等类模板中，模板参数包必须是模板形参列表的最后一个形参。所以这是错误的&lt;code class=&quot;highlighter-rouge&quot;&gt;template&amp;lt;typename... Ts, typename U&amp;gt; struct Invalid;&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Ts.. 应该放在结尾&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在函数模板中，模板参数包可以在列表中早于所有能从函数实参推导的参数出现，或拥有默认参数。所以：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename ...Ts, typename U, typename=void&amp;gt;
void valid(U, Ts...);     // OK ：能推导 U
// void valid(Ts..., U);  // 不能使用： Ts... 在此位置是非推导语境 
valid(1.0, 1, 2, 3);      // OK ：推导 U 为 double ， Ts 为 {int,int,int}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;右值引用&quot;&gt;右值引用&lt;/h2&gt;

&lt;p&gt;为了解决：第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。&lt;/p&gt;

&lt;p&gt;区分左值和右值：能不能对表达式取地址，如果能，则为左值，否则为右值&lt;/p&gt;

&lt;p&gt;非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = getVar(); // i是左值
T&amp;amp;&amp;amp; k = getVar(); // getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”。
                  // 他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int g_constructCount=0;
struct{
  A(){
        cout&amp;lt;&amp;lt;&quot;construct: &quot;&amp;lt;&amp;lt;++g_constructCount&amp;lt;&amp;lt;endl;    
     }
};
A GetA()
{
    return A();
}
int main(){
  A a = GetA(); //需要生成临时对象，而后销毁临时对象
  const A&amp;amp; a = GetA(); // 与下面这句一样，少了一次拷贝和析构
  A&amp;amp;&amp;amp; a = GetA(); //少了一次拷贝和析构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构。&lt;/p&gt;

&lt;p&gt;常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：&lt;code class=&quot;highlighter-rouge&quot;&gt;A&amp;amp; a = GetA();&lt;/code&gt;。但是右值引用独立于左值和右值，意思是右值引用类型的变量可能是左值也可能是右值，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp; t&lt;/code&gt;在&lt;strong&gt;发生自动类型推断&lt;/strong&gt;的时候(一般都是模板的T&amp;amp;&amp;amp;)，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。&lt;/p&gt;

&lt;p&gt;变量1 = 函数()–&amp;gt;返回值：这时出现函数返回一个临时变量，拷贝给变量1，一般此时要求返回值、变量的复制构造函数完成深拷贝，否则可能发生指针悬挂的问题，但是可以设置复制构造函数为&lt;code class=&quot;highlighter-rouge&quot;&gt;A(A&amp;amp;&amp;amp; a) :m_ptr(a.m_ptr)&lt;/code&gt;，这时只完成浅拷贝（移动构造，实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;std::move&lt;/code&gt;实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用），即函数返回的右值直接付给了变量1，由于右值没有内存地址，所以不会发生指针悬挂的问题；以前的方式可以采用这样&lt;code class=&quot;highlighter-rouge&quot;&gt;A(const A&amp;amp; a):m_ptr(new int(*a.m_ptr))&lt;/code&gt;完成深拷贝复制构造。&lt;/p&gt;

&lt;h2 id=&quot;完美转发&quot;&gt;完美转发&lt;/h2&gt;

&lt;p&gt;C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。&lt;/p&gt;

&lt;p&gt;最后给出一个使用完美转发的泛型模板：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename…  Args&amp;gt;
T* Instance(Args&amp;amp;&amp;amp;… args)
{
    return new T(std::forward&amp;lt;Args &amp;gt;(args)…);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。&lt;/p&gt;

</description>
        <pubDate>Fri, 20 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/20/cpp-11-14-17/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/20/cpp-11-14-17/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Grid Map developed by ETHz</title>
        <description>&lt;h2 id=&quot;grid-map-can-contain-multiple-map-layers&quot;&gt;Grid map can contain multiple map layers&lt;/h2&gt;

&lt;p&gt;The following map is constructed with one layer called “elevation”.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace grid_map;
GridMap map({&quot;elevation&quot;});
for (GridMapIterator it(map); !it.isPastEnd(); ++it){
  Position position;
  map.getPosition(*it, position);
  map.at(&quot;elevation&quot;, *it) = -0.04 + 0.2 * std::sin(3.0 * time.toSec() + 5.0 * position.y()) * position.x();
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 03 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/03/ethz-grid-map/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/03/ethz-grid-map/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Real-time Control System</title>
        <description>&lt;p&gt;&lt;strong&gt;千万不要以rcs-test等短划线的方式命名RCS工程&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rcs-structure&quot;&gt;RCS Structure&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;{project-name}.nml //配置buffer文件，使用#注释&lt;/li&gt;
  &lt;li&gt;{project-name}svr.cc //server源文件，编译后变为可执行文件&lt;/li&gt;
  &lt;li&gt;{project-name}main.cc //main程序，其中定义了module对象，并循环执行module中的××_process()&lt;/li&gt;
  &lt;li&gt;{module-name}_module.cc // 模块代码，工程的功能模块&lt;/li&gt;
  &lt;li&gt;{module-name}.hh // 对应上面的module.cc，是它的头文件&lt;/li&gt;
  &lt;li&gt;{module-name}n.hh //模块的status和command通道&lt;/li&gt;
  &lt;li&gt;{aux-channel}n.hh //工程的辅助通道&lt;/li&gt;
  &lt;li&gt;GNUmakefile // makefile文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rcs-config&quot;&gt;RCS Config&lt;/h2&gt;

&lt;p&gt;RCS中主要的配置都在.nml文件中，nml文件可以分为三部分：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;module-name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;srv&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果使用的buffer不是该工程的srv建立的，但该工程使用了这个buffer，那么在buffer和module-name部分都要声明这个buffer，但&lt;strong&gt;srv&lt;/strong&gt;部分没有这个buffer，对应&lt;strong&gt;{project-name}svr.cc&lt;/strong&gt;中也没有关于该buffer的构建的code。
{Note} 该工程的nml文件中buffer部分声明的使用的buffer需要和定义该buffer的（srv申请的buffer）工程中的buffer MP必须相同，TCP貌似也应该相同。&lt;/p&gt;

&lt;h2 id=&quot;rcs-module&quot;&gt;RCS Module&lt;/h2&gt;

&lt;p&gt;在声明辅助通道时候，如果该module是input该辅助通道，那么一般会这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//&amp;lt;module-name&amp;gt;.hh
NML * ×××_CHANNEL;//
×××_MSG * ×××_data;//这是一个指针
//&amp;lt;module-name&amp;gt;_module.cc
×××_CHANNEL = new NML(×××Format, &quot;&amp;lt;buffer-name&amp;gt;&quot;, &quot;&amp;lt;moudle-name&amp;gt;&quot;, &quot;×××.nml&quot;);
×××_data = (×××_MSG *) ×××_CHANNEL-&amp;gt;get_address();
switch(SLAMPOSAZIM_CHANNEL-&amp;gt;read())
{
  case ×××_MSG_TYPE:
          do-someting....;
	break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果该module是output该辅助通道，那么一般会这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NML * ×××_CHANNEL;//
×××_MSG ×××_data;//这是一个对象
×××_CHANNEL = new NML(×××Format, &quot;&amp;lt;buffer-name&amp;gt;&quot;, &quot;&amp;lt;moudle-name&amp;gt;&quot;, &quot;×××.nml&quot;);
...赋值操作。。。
×××_CHANNEL-&amp;gt;write(&amp;amp;×××_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;命令通道&quot;&gt;命令通道&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&quot;两个文件夹在一台电脑上共用一个辅助通道&quot;&gt;两个文件夹在一台电脑上共用一个辅助通道&lt;/h2&gt;

&lt;p&gt;nml配置：对于这个通道的而言，其buffer number/MP/TCP port保持一致，否则diag_NB.jar会报错。&lt;/p&gt;

&lt;h2 id=&quot;diag_nbjar&quot;&gt;diag_NB.jar&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -jar /usr/local/diag_NB.jar
在对话框里open **.cfg
这个过程需要打开cfg文件中提到的channel的P_**n.hh，否则diag_NB无法确定channel的类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改nml文件注意事项&quot;&gt;修改nml文件注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在nml文件中增加删除某个buffer，注意更改相应的××svr.cc中的该buffer对应的channel相关代码&lt;/li&gt;
  &lt;li&gt;由codegen.jar将{aux_channel}n.hh得到的{aux_channel}n_n.cc中会自动生成一个关于该通道最小是多少数值，供参考。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;rcs-struct类型的声明&quot;&gt;RCS struct类型的声明&lt;/h2&gt;

&lt;p&gt;DECLARE_NML_DYNAMIC_LENGTH_ARRAY({类型名}, 数组变量名, 数组的最大长度);//声明一个数组&lt;/p&gt;

&lt;p&gt;在某个{aux_channel}n.hh中需要声明一个struct{结构体};，需要在该文件中同时声明&lt;code class=&quot;highlighter-rouge&quot;&gt;extern void nmlupdate(CMS *cms, {结构体名称} *x);&lt;/code&gt;，这将通过codegen产生结构体的构造函数&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/06/29/realtimecontrolsystem/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/06/29/realtimecontrolsystem/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode</title>
        <description>&lt;h2 id=&quot;euler-and-quaternion&quot;&gt;Euler and Quaternion&lt;/h2&gt;

&lt;h3 id=&quot;from-euler-to-quaternion&quot;&gt;From Euler to Quaternion:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace Eigen;
//Roll pitch and yaw in Radians
float roll = 1.5707, pitch = 0, yaw = 0.707;    
Quaternionf q;
q = AngleAxisf(roll, Vector3f::UnitX())
    * AngleAxisf(pitch, Vector3f::UnitY())
    * AngleAxisf(yaw, Vector3f::UnitZ());
std::cout &amp;lt;&amp;lt; &quot;Quaternion&quot; &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; q.coeffs() &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;from-quaternion-to-euler&quot;&gt;From Quaternion to Euler:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto euler = q.toRotationMatrix().eulerAngles (0, 1, 2);
std::cout &amp;lt;&amp;lt; &quot;Euler from quaternion in roll, pitch, yaw&quot;&amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; euler &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;use-eigenisometry3d-pose-to-describe-translation-and-rotation&quot;&gt;Use Eigen::Isometry3d pose to describe translation and rotation&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::Isometry3d pose; //4 by 4 matrix in fact
pose.linear() = q.normalized().toRotationMatrix();
pose(0,3) = pos_x;
pose(1,3) = pos_y;
pose(2,3) = pos_z;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;an-affine-transformation-to-an-isometric-transformation&quot;&gt;an affine transformation to an isometric transformation&lt;/h2&gt;

&lt;p&gt;b.rotation() extract the rotation part of the transformation. It involves a SVD, and thus it is read-only. On the left hand side, you have to use .linear():&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::AffineCompact3f a;
Eigen::Isometry3f b;
b.translation() = a.translation();
b.linear() = a.rotation();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you know that ‘a’ is an isometry and only want to cast it to an Isometry 3f, you can simply do:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b = a.matrix();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/06/13/laser-process/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/06/13/laser-process/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
