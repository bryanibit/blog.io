<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>屋顶上的鱼</title>
    <description>于华超</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 07 Oct 2018 00:44:38 +0800</pubDate>
    <lastBuildDate>Sun, 07 Oct 2018 00:44:38 +0800</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>Daily Plan</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Add &lt;strong&gt;github star repo&lt;/strong&gt; to plan!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;模仿gridmap_octomap–&amp;gt;interactivepc将octomap投影到nav_msgs/occupancy&lt;/p&gt;

&lt;h1 id=&quot;2018-7-第一个周&quot;&gt;2018-7 第一个周&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;搞懂ETHZ的gird map和运行Autoware效果,读几篇Hibert maps相关文章
boost::bind(), git submodule, ros::Time(0), ros::WallTime(0), 多线程相机驱动的关闭问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-2-1&quot;&gt;2018-7-2 :+1:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：查看关于grid地图的多种方法，读一篇文献&lt;/li&gt;
  &lt;li&gt;下午：看公开课，完成一周（第8周）的内容，并做笔记&lt;/li&gt;
  &lt;li&gt;晚上：树mei派安装gitlab + download所有的依赖for工作站（到8：00～8：30） + 运动&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-3-tada&quot;&gt;2018-7-3 :tada:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：读完grid_map的论文，共22页&lt;/li&gt;
  &lt;li&gt;下午：看公开课，看到第九周的内容&lt;/li&gt;
  &lt;li&gt;晚上：读一篇英文小说，傲慢与偏见20分钟，对下午没有看完的第九周课程，继续看一下&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-4-rocket&quot;&gt;2018-7-4 :rocket:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：查看gridmap的readme，使用gridmap运行包中的pointcloud数据&lt;/li&gt;
  &lt;li&gt;下午：查看elevation_map的代码&lt;/li&gt;
  &lt;li&gt;晚上：读一篇英文小说，傲慢与偏见20分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-5-metal&quot;&gt;2018-7-5 :metal:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：抛弃elevation_map，查看volumetric_map和grid_map直接绘制地图的可能性&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：公开课完成第9周前两节课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-6-octocat&quot;&gt;2018-7-6 :octocat:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：不使用octomap，直接使用gridmap，尝试pointcloud&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：空&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2018-7-第二个周&quot;&gt;2018-7 第二个周&lt;/h1&gt;

&lt;h2 id=&quot;2018-7-9--camel&quot;&gt;2018-7-9  :camel:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：完成RCS建构搭建&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：看公开课第九周&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-10--sparkles&quot;&gt;2018-7-10  :sparkles:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：安装新电脑&lt;/li&gt;
  &lt;li&gt;下午：集成浙大slam代码&lt;/li&gt;
  &lt;li&gt;晚上：公开课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-11&quot;&gt;2018-7-11&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：docker-gitlab端口映射的搭建&lt;/li&gt;
  &lt;li&gt;下午：同上，验收激光雷达&lt;/li&gt;
  &lt;li&gt;晚上：docker搭建验收&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-12&quot;&gt;2018-7-12&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：修改Yaowen的ANS模块&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：公开课&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-13&quot;&gt;2018-7-13&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;上午：修改ANS模块，现在将nml改完了，明天要改cfg，并用diag_NB工具调试&lt;/li&gt;
  &lt;li&gt;下午：同上&lt;/li&gt;
  &lt;li&gt;晚上：聚餐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-14&quot;&gt;2018-7-14&lt;/h2&gt;

&lt;p&gt;:octocat: 确认新的模块是可以运行的&lt;/p&gt;

&lt;p&gt;bryan/ANS_test是push到git的模块; 桌面hee是由基于master修改的ans和原来的zt; bryan里面的hee-originalverson是没有修改的ans（没有加入sjdw-module的）和原来的zt&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上午：&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2018-7-18&quot;&gt;2018-7-18&lt;/h2&gt;

&lt;p&gt;git中origin master（branch）和 working space 暂存区的区别，commit是到分支上而暂存区是每个分支共有吗？&lt;/p&gt;

&lt;p&gt;看代码rcslib源码，传递long型的效果&lt;/p&gt;

&lt;p&gt;/etc/modprode   /dev/rule.d&lt;/p&gt;

&lt;p&gt;办理电脑入网，打电话给王申&lt;/p&gt;

&lt;p&gt;询问张凯路径重规划的问题&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上午：抽一会儿看一下线程的概念&lt;/li&gt;
  &lt;li&gt;下午：今天任务大约完成&lt;/li&gt;
  &lt;li&gt;晚上：English&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;we will stick to the strictest definition in the interest of clarity.&lt;/p&gt;

&lt;p&gt;go to the horse’s mouth&lt;/p&gt;

&lt;p&gt;属性图-概率图  场景建模模块 加个通道，
64线，读32线，三张图，同样的消息类型&lt;/p&gt;

&lt;h2 id=&quot;2018-7-31&quot;&gt;2018-7-31&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Merge code to track_uvc from dev_zjd&lt;/li&gt;
  &lt;li&gt;采集数据&lt;/li&gt;
  &lt;li&gt;激光标定&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;国庆9天&quot;&gt;国庆9天&lt;/h2&gt;

&lt;p&gt;:camel: 多完成的加以备注&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;9-29&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective c++ 第一章（笔记blog）&lt;/li&gt;
  &lt;li&gt;the giver 20th 21st&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;9-30&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective c++ 第二章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(函数式编程，面向对象编程，面向对象高级编程)(笔记blog)&lt;/li&gt;
  &lt;li&gt;the giver 22th and the left&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-1&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a rest&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-2&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a rest&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-3&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第三章&lt;/li&gt;
  &lt;li&gt;liaoxuefeng python(错误调试，IO编程)&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-4&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Take a test&lt;/li&gt;
  &lt;li&gt;二十年&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-5&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第四章&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-6&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第五章&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-7&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;effective C++ 第六章&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;10-8&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Go to work&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/10/02/daily-plan/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/10/02/daily-plan/</guid>
        
        <category>个人总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Effective C++</title>
        <description>&lt;h1 id=&quot;1-template-type-deduce&quot;&gt;1. template type deduce&lt;/h1&gt;

&lt;p&gt;The behaviour and purpose&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(ParamType param);
f(expr); // deduce T and ParamType from expr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-referencepointer-之-lvalue-reference&quot;&gt;by-reference/pointer 之 lvalue-reference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;by-reference said &lt;em&gt;const int&lt;/em&gt; is different from &lt;em&gt;int&lt;/em&gt;. To be honest, both are different anywhere.&lt;/li&gt;
  &lt;li&gt;If expr’s type is a reference, ignore the reference part.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param); // param is a reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is int&amp;amp;
f(cx); // T is const int, param's type is const int&amp;amp;
f(rx); // T is const int, param's type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp; param); // param is a const reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is const int&amp;amp;
f(cx); // T is int, param's type is const int&amp;amp;
f(rx); // T is int, param's type is const int&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T* param); // param is a pointer
int x = 27; // x is an int
const int *cx = &amp;amp;x; // cx is a const int *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(&amp;amp;x); // T is int, param's type is int*
f(px); // T is const int, param's type is const int*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-reference-之-universal-reference&quot;&gt;by-reference 之 universal-reference&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If &lt;em&gt;expr&lt;/em&gt; is an lvalue, both T and ParamType are deduced to be lvalue references.&lt;strong&gt;it’s the only situation in template type deduction where T is deduced to be a reference.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;If expr is an rvalue, the “normal” (i.e., the above Case 1) rules apply.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp;&amp;amp; param); // param is a universal reference
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int&amp;amp;, param's type is int&amp;amp;
f(cx); // T is const int&amp;amp;, param's type is const int&amp;amp;
f(rx); // T is const int&amp;amp;, param's type is const int&amp;amp;
f(32); // 32 is rvalue, T is int, param's type is int&amp;amp;&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;by-value&quot;&gt;by-value&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Rule&lt;/strong&gt; is :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;if expr’s type is a reference, ignore the reference part.&lt;/li&gt;
  &lt;li&gt;if expr is const, ignore that, too. If it’s volatile, also ignore that&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T param); // param is now pass by value
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int&amp;amp; rx = x; // rx is a reference to x as a const int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;f(x); // T is int, param's type is int
f(cx); // T is int, param's type is int
f(rx); // T is int, param's type is int
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is because param is an object that’s completely independent of cx and rx—a copy of cx or rx. The fact that cx and rx can’t be modified says nothing about whether param can be. That’s why expr’s constness (and volatileness, if any) is ignored when deducing a type for param.&lt;/p&gt;

&lt;h3 id=&quot;array-arguments&quot;&gt;Array Arguments&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const char name[] = &quot;J. P. Briggs&quot;;
const char * ptrToName = name;
template&amp;lt;typename T&amp;gt;
void f(T param); // template with by-value parameter
f(name); // T is deduced to const char *, param is the same.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the above is changed to:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(T&amp;amp; param); // template with by-reference parameter
f(name); // T is deduced to const char [13], param is const char (&amp;amp;) [13]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;return size of an array as a compile-time constant.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T, std::size_t N&amp;gt;
constexpr std::size_t arraySize(**T (&amp;amp;) [N]**) noexcept //result availble during compilation
{
	return N;
}
int keyvals [] = {1,2,3,4,5,6,7};
int mapvals [arraySize(keyvals)];
std::array&amp;lt;int, arraySize(keyVals)&amp;gt; mappedVals;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;function-arguments&quot;&gt;Function Arguments&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void someFunc(int, double); // someFunc is a function; type is void(int, double)
template&amp;lt;typename T&amp;gt;
void f1(T param); // in f1, param passed by value
template&amp;lt;typename T&amp;gt;
void f2(T&amp;amp; param); // in f2, param passed by ref
f1(someFunc); // param deduced as ptr-to-func; type is void (*)(int, double)
f2(someFunc); // param deduced as ref-to-func; type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Things to Remember
• During template type deduction, arguments that are references are treated as
non-references, i.e., their reference-ness is ignored.
• When deducing types for universal reference parameters, lvalue arguments get
special treatment.
• When deducing types for by-value parameters, const and/or volatile argu‐
ments are treated as non-const and non-volatile.
• During template type deduction, arguments that are array or function names
decay to pointers, unless they’re used to initialize references.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-auto-type-deduction&quot;&gt;2. auto type deduction&lt;/h1&gt;

&lt;h2 id=&quot;same-with-template-type-deduction&quot;&gt;Same with template type deduction&lt;/h2&gt;

&lt;p&gt;When a variable is declared using &lt;em&gt;auto&lt;/em&gt;, auto plays the role of &lt;strong&gt;T&lt;/strong&gt; in the template, and
the type specifier for the variable acts as &lt;em&gt;ParamType&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------------lvalue reference-------------
auto x = 27; //auto is deducted to int, x is int
const auto cx = x; //auto is deducted to int, cx is const int
const auto&amp;amp; rx = x; // auto is deducted to int, rx is const int&amp;amp;
--------------universal reference--------
auto&amp;amp;&amp;amp; uref1 = x; // x is int and lvalue, so uref1's type is int&amp;amp;
auto&amp;amp;&amp;amp; uref2 = cx; // cx is const int and lvalue, so uref2's type is const int&amp;amp;
auto&amp;amp;&amp;amp; uref3 = 27; // 27 is rvalue, so uref3's type is int&amp;amp;&amp;amp;
const char name[] = // name's type is const char[13]
----------array and function-------------
&quot;R. N. Briggs&quot;;
auto arr1 = name; // arr1's type is const char*
auto&amp;amp; arr2 = name; // arr2's type is const char (&amp;amp;)[13]
void someFunc(int, double); // someFunc is a function; type is void(int, double)
auto func1 = someFunc; // func1's type is void (*)(int, double)
auto&amp;amp; func2 = someFunc; // func2's type is void (&amp;amp;)(int, double)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The template type deduction is the same with the auto type deduction. They are essentially
two sides of the same coin. Except for the one way they differ.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int x1 = 27;
int x2(27);
int x3 = {27};
int x4{27}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above is the same in c++11 to one result: an int with value 27. And use &lt;em&gt;auto&lt;/em&gt; to replace the above &lt;em&gt;int&lt;/em&gt;.
Then the first two is ditto and the last two ones become &lt;code class=&quot;highlighter-rouge&quot;&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;. The treatment of braced(means {}) initializers is the only way in which auto type deduction and template type deduction differ. So the only real difference between auto and template type deduction is that auto assumes that a braced initializer represents a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::initializer_list&lt;/code&gt;, but template type deduction doesn’t. The evidence is shown the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
void f(T param);
f({1,2,3}); // fail
template &amp;lt;typename T&amp;gt;
void f(std::initializer_list&amp;lt;T&amp;gt; param);
f({1,2,3}); // OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In C++14, the tale continues. C++14 permits auto to indicate that a function’s return type should be deduced, and
C++14 lambdas may use auto in parameter declarations.
auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.&lt;/p&gt;

&lt;h1 id=&quot;3-understand-decltype&quot;&gt;3. Understand decltype&lt;/h1&gt;

&lt;h2 id=&quot;decltype-type&quot;&gt;decltype type&lt;/h2&gt;

&lt;p&gt;decltype saves the original type of variable, no complex deduction.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Widget w;
const Widget&amp;amp; cw = w;
auto myWidget1 = cw; // auto type deduction(by-value): myWidget1's type is Widget
decltype(auto) myWidget2 = cw; // decltype type deduction: myWidget2's type is const Widget&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Just like the above &lt;code class=&quot;highlighter-rouge&quot;&gt;myWidget1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;myWidget2&lt;/code&gt;, the value of function returning can not be auto. If not, the reference and anyother things will diminish.&lt;/p&gt;

&lt;p&gt;In according to rvalue and lvalue, the function’s parameter becomes universal reference.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename Container, typename Index&amp;gt; // final
decltype(auto) 															 // C++14
authAndAccess(Container&amp;amp;&amp;amp; c, Index i) 			 // version
{
authenticateUser();
return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
--------------------------------------
template&amp;lt;typename Container, typename Index&amp;gt; // final
auto 																				 // C++11
authAndAccess(Container&amp;amp;&amp;amp; c, Index i) 			 // version
-&amp;gt; decltype(std::forward&amp;lt;Container&amp;gt;(c)[i])
{
authenticateUser();
return std::forward&amp;lt;Container&amp;gt;(c)[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-1&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Things to Remember
 • decltype almost always yields the type of a variable or expression without any modifications.
 • For lvalue expressions of type T other than names, decltype always reports a type of T&amp;amp;.
 • C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.
 • auto variables have their type deduced from their initializer,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;4-know-how-to-view-deduced-types&quot;&gt;4. Know how to view deduced types&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::type_info::name&lt;/code&gt; mandates that the type be treated as if it had been passed to a template
function as a by-value parameter. e.g.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;typeinfo&amp;gt;
std::cout &amp;lt;&amp;lt; typeid(x).name() &amp;lt;&amp;lt; '\n'; // display types for
std::cout &amp;lt;&amp;lt; typeid(y).name() &amp;lt;&amp;lt; '\n'; // x and y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Boost TypeIndex library (often written as Boost.TypeIndex) is designed to succeed. And I don’t want to expand the content.&lt;/p&gt;

&lt;h1 id=&quot;5-prefer-auto-to-explicit-type-declarations&quot;&gt;5. Prefer auto to explicit type declarations&lt;/h1&gt;

&lt;p&gt;Here, we insert something irrelevant to &lt;em&gt;auto&lt;/em&gt;. It is how to reserve bidirectional iterators:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iterator&amp;gt;
template&amp;lt;class BidirIt&amp;gt;
void my_reverse(BidirIt first, BidirIt last)
{
    typename std::iterator_traits&amp;lt;BidirIt&amp;gt;::difference_type n = std::distance(first, last);//complete written
		//auto n = std::distance(first, last);//correct like ditto
    --n;
    while(n &amp;gt; 0) {
        typename std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type tmp = *first;//complete written
				//auto tmp = *first;//correct like ditto
        *(first++) = *(--last);
        *last = tmp;
        n -= 2;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;std::function&lt;/strong&gt; is a template in the C++11 Standard Library that &lt;em&gt;generalizes&lt;/em&gt; the idea of a function pointer. But you must specify the type of function(function signature) to refer to when you create a std::function object. the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::function&lt;/code&gt; approach is generally bigger and slower than the &lt;em&gt;auto&lt;/em&gt; approach, and it may yield out-of-memory exceptions, too.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; v;
unsigned int n = v.size()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To be honest, the real returning type of &lt;code class=&quot;highlighter-rouge&quot;&gt;v.size()&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;int&amp;gt;::size_type&lt;/code&gt;. It is the same with &lt;em&gt;unsigned int&lt;/em&gt; on 32-bit, but different on 64-bit.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::unordered_map&amp;lt;std::string, int&amp;gt; m;
for(std::pair&amp;lt;std::string, int&amp;gt; &amp;amp;p: m){}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This seem perfectly reasonable. But std::unordered_map’s key is &lt;em&gt;const&lt;/em&gt;, so it it std::pair&amp;lt;const std::string, int&amp;gt;. That will result in a temporary object producing. Use auto: &lt;code class=&quot;highlighter-rouge&quot;&gt;for(const auto&amp;amp; p: m){}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The above examples show how	&lt;strong&gt;explicitly specifying&lt;/strong&gt; types can lead to &lt;strong&gt;implicit conversions&lt;/strong&gt; that you neither want nor expect. If you use &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt; as the type of the target variable, you need not worry about mismatches between the type of variable you’re declaring and the type of the expression used to initialize it.&lt;/p&gt;

&lt;h1 id=&quot;6-use-the-explicitly-typed-initializer-idiom-when-auto-deduces-undesired-types&quot;&gt;6. Use the explicitly typed initializer idiom when auto deduces undesired types.&lt;/h1&gt;

&lt;p&gt;First of all, we see the example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Widget w;
bool highPriority = feature(w)[5]; //std::vector&amp;lt;bool&amp;gt; feature(Widget);
processWidget(w, highPriority);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The code is right, but we can change that to the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto highPriority = feature(w)[5];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;[ ] return T&amp;amp;, auto here is deduced bool&amp;amp; as matter of course. But C++ is not empowered to use &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&amp;amp;&lt;/code&gt;. So &lt;em&gt;highPriority&lt;/em&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt;. One implementation is for such objects to contain a pointer to the machine word holding the referenced bit,
plus the offset into that word for that bit. So the above code has some problems: highPriority references the type function feature returns which is a temporay object and is reserved until the sentence “feature(w)[5] finishs.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is an example of a &lt;strong&gt;proxy class&lt;/strong&gt;: a class that exists for the purpose of emulating and augmenting the behavior of some other type. As a general rule, “invisible” proxy classes don’t play well with auto. The explicitly typed initializer idiom involves declaring a variable with auto, but casting the initialization expression to the type you want auto to deduce. The code above is modified like that:&lt;code class=&quot;highlighter-rouge&quot;&gt;auto highPriority = static_cast&amp;lt;bool&amp;gt;(features(w)[5]);&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-2&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• “Invisible” proxy types can cause auto to deduce the “wrong” type for an ini‐
tializing expression.
• The explicitly typed initializer idiom forces auto to deduce the type you want
it to have.
• Implicit type deduction is forbidden in C++11 and easy to result in undefined behaviour.
Sometimes, static_cast&amp;lt;&amp;gt; is adopted with auto.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;7-distinguish-between--and--when-creating-objects&quot;&gt;7. Distinguish between () and {} when creating objects&lt;/h1&gt;

&lt;p&gt;What can {} do?&lt;/p&gt;

&lt;p&gt;Let try something simple.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Widget w1(10);// call Widget ctor with argument 10
Widget w2(); //error, compiler see it to function returning Widget class
Widget w3{}; // calls Widget ctor with no args
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto i = {1};
typeid(i).name() //i, int
auto j = {1, 2};
typeid(j).name() //St16initializer_listIiE, initializer_list&amp;lt;int&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;We can see that {multiple element} will be an initializer_list. For example,&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
public:
Widget(int i, bool b);
Widget(int i, double d);
Widget(std::initializer_list&amp;lt;bool&amp;gt; il); // element type is now bool
... // no implicit conversionEntities funcs
};
Widget w{10, 5.0}; // use initializer_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;One rule is that {} is not allowed implicit conversion, but I think it it not certain every time. But if the code above is changed to &lt;code class=&quot;highlighter-rouge&quot;&gt;Widget(std::initializer_list&amp;lt;std::string&amp;gt; il)&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;Widget w{10, 5.0}&lt;/code&gt; will use &lt;code class=&quot;highlighter-rouge&quot;&gt;Widget(int i, double d)&lt;/code&gt; as ctor.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; has initializer_list ctor, so&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector v1(10, 20); // 10 20s
std::vector v1{10, 20}; //two elements 10 and 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-3&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;						Things to Remember
• Braced initialization is the most widely usable initialization syntax, it prevents
narrowing conversions, and it’s immune to C++’s most vexing parse.
• During constructor overload resolution, braced initializers are matched to
std::initializer_list parameters if at all possible, even if other construc‐
tors offer seemingly better matches.
• An example of where the choice between parentheses and braces can make a
significant difference is creating a std::vector&amp;lt;numeric type&amp;gt; with two
arguments.
• Choosing between parentheses and braces for object creation inside templates
can be challenging.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;prefer-nullptr-to-0-and-null&quot;&gt;Prefer nullptr to 0 and NULL&lt;/h2&gt;

&lt;p&gt;It is the blending of NULL and 0 that C++98 programmers avoid overloading on pointer and
integral types. &lt;code class=&quot;highlighter-rouge&quot;&gt;“I’m calling f with NULL -- the null pointer”&lt;/code&gt; and its actual meaning &lt;code class=&quot;highlighter-rouge&quot;&gt;“I’m calling f with
some kind of integrals -- not the null pointer”&lt;/code&gt;. NULL has a integer type and nullptr’s advantage is that it doesn’t have an integral type.
You can think &lt;strong&gt;nullptr&lt;/strong&gt; as a point of all type.&lt;/p&gt;

&lt;p&gt;nullptr is derived from &lt;code class=&quot;highlighter-rouge&quot;&gt;std::nullptr_t&lt;/code&gt;, which can convert to any raw pointers.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void* a = nullptr;
a == 0; // true
int a = 0;
a == nullptr; //error: invalid operands of types ‘int’
              //and ‘std::nullptr_t’ to binary ‘operator==’
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;conclusion-4&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Prefer nullptr to 0 and NULL.
• Avoid overloading on integral and pointer types.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;9-prefer-alias-declarations-to-typedefs&quot;&gt;9. Prefer alias declarations to typedefs&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//a unique_ptr
typedef std::unique_ptr&amp;lt;std::unordered_map&amp;lt;std::string, std::string&amp;gt;&amp;gt; UPtrMapSS; //c++ 98
using UPtrMapSS = std::unique_ptr&amp;lt;std::unordered_map&amp;lt;std::string, std::string&amp;gt;&amp;gt;; //c++ 11
//FP is a synonym for a pointer to a function taking an int and
// a const std::string&amp;amp; and returning nothing
typedef void (*FP)(int, const std::string&amp;amp;)
using FP = void (*)(int, const std::string&amp;amp;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;alias-template&quot;&gt;alias template&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//set structure member saving typedef objects
template&amp;lt;typename T&amp;gt; // MyAllocList&amp;lt;T&amp;gt;::type is synonym for std::list&amp;lt;T,MyAlloc&amp;lt;T&amp;gt;&amp;gt;
struct MyAllocList {
typedef std::list&amp;lt;T, MyAlloc&amp;lt;T&amp;gt;&amp;gt; type; //type could change to any name you like
};
MyAllocList&amp;lt;Widget&amp;gt;::type lw; // client code
---------------------------
template&amp;lt;typename T&amp;gt;
using MyAllocList = std::list&amp;lt;T, MyAlloc&amp;lt;T&amp;gt;&amp;gt;; // MyAllocList&amp;lt;T&amp;gt; is synonym for std::list&amp;lt;T,MyAlloc&amp;lt;T&amp;gt;&amp;gt;
MyAllocList&amp;lt;Widget&amp;gt; lw; // client code
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you want to use typedef inside a template for purpose of creating a linked list holding
objects of a type specified by a template parameter, you need to precede the &lt;strong&gt;typedef name&lt;/strong&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;typename&lt;/code&gt;.
For instance,&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
class Widget{
	private:
		typename MyAllocList&amp;lt;T&amp;gt;::type lw;// structure member type
		...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here, MyAllocList&lt;T&gt;::type refers to a type that’s dependent on a template type
parameter (T). MyAllocList&lt;T&gt;::type is thus a *dependent type*, and one of C++’s
many endearing rules is that the names of dependent types must be preceded by type
name.&lt;/T&gt;&lt;/T&gt;&lt;/p&gt;

&lt;p&gt;If MyAllocList is defined as an alias template, this need for typename vanishes (as
does the cumbersome “::type” suffix):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
class Widget{
	private:
	MyAllocList&amp;lt;T&amp;gt; lw;
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Alias template must name a type, &lt;code class=&quot;highlighter-rouge&quot;&gt;MyAllocList&amp;lt;T&amp;gt;&lt;/code&gt; above is thus a &lt;em&gt;non-dependent&lt;/em&gt; type. A &lt;strong&gt;typename&lt;/strong&gt;
specifier is neither required nor permitted. However compiler can not know &lt;code class=&quot;highlighter-rouge&quot;&gt;MyAllocList&amp;lt;T&amp;gt;::type&lt;/code&gt;, which
just a structure member object, so need &lt;strong&gt;typename&lt;/strong&gt; to tell compiler it refers to a type.&lt;/p&gt;

&lt;h2 id=&quot;header-file-&quot;&gt;header file &lt;type_traits&gt;&lt;/type_traits&gt;&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::remove_const&amp;lt;T&amp;gt;::type // yields T from const T
std::remove_reference&amp;lt;T&amp;gt;::type // yields T from T&amp;amp; and T&amp;amp;&amp;amp;
std::add_lvalue_reference&amp;lt;T&amp;gt;::type // yields T&amp;amp; from T
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C++14 add something simplified:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::remove_const&amp;lt;T&amp;gt;::type 					// C++11: const T → T
std::remove_const_t&amp;lt;T&amp;gt;     					// C++14 equivalent
std::remove_reference&amp;lt;T&amp;gt;::type 			// C++11: T&amp;amp;/T&amp;amp;&amp;amp; → T
std::remove_reference_t&amp;lt;T&amp;gt;     			// C++14 equivalent
std::add_lvalue_reference&amp;lt;T&amp;gt;::type  // C++11: T → T&amp;amp;
std::add_lvalue_reference_t&amp;lt;T&amp;gt;      // C++14 equivalent
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above is achieved by :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;class T&amp;gt;
using remove_const_t = typename remove_const&amp;lt;T&amp;gt;::type;
template &amp;lt;class T&amp;gt;
using remove_reference_t = typename remove_reference&amp;lt;T&amp;gt;::type;
template &amp;lt;class T&amp;gt;
using add_lvalue_reference_t = typename add_lvalue_reference&amp;lt;T&amp;gt;::type;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-5&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• typedefs don’t support templatization, but alias declarations do.
• Alias templates avoid the “::type” suffix and, in templates, the “typename”
prefix often required to refer to typedefs.
• C++14 offers alias templates for all the C++11 type traits transformations.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;10-prefer-scoped-enum-s-to-unscoped-enum-s&quot;&gt;10. Prefer scoped enum s to unscoped enum s&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Color { black, white, red }; // unscoped enum
Color c = red;
--------------------------------
enum class Color { black, white, red }; // enum is now scoped
Color c = Color::red;
c &amp;gt; 14.5;//error, c is class, can not compare with int
static_cast&amp;lt;int&amp;gt;(c) &amp;gt; 14.5; // OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In practice, the declaration and definition of enum are separated:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class Status; // forward declaration(.h)
enum class Status{one, two, three}; // definition(.cc)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;em&gt;Status&lt;/em&gt;’s underlying type is int. We can specify it using:&lt;code class=&quot;highlighter-rouge&quot;&gt;enmu class Status:std::uint32_t{one, two}&lt;/code&gt;(combine definition and declaration from &lt;cstdin&gt;). We can often use enum as int number, for example:&lt;/cstdin&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// unscoped enum
using UserInfo = std::tuple&amp;lt;std::string, std::string, std::size_t&amp;gt;
enum UserInfoFields { uiName, uiEmail, uiReputation };
UserInfo uInfo;
auto val = std::get&amp;lt;uiEmail&amp;gt;(uInfo);//tuple member function get&amp;lt;T&amp;gt;()
---------------------------------------
// scoped enum
using UserInfo = std::tuple&amp;lt;std::string, std::string, std::size_t&amp;gt;
enum class UserInfoFields { uiName, uiEmail, uiReputation };
UserInfo uInfo;
auto val = std::get&amp;lt;static_cast&amp;lt;std::size_t&amp;gt;(UserInfoFields::uiEmail)&amp;gt;(uInfo);//tuple member function get&amp;lt;T&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In fact, there is a function which access &lt;strong&gt;enum&lt;/strong&gt;’s underlying type via the &lt;code class=&quot;highlighter-rouge&quot;&gt;std::underlying_type&lt;/code&gt; type trait.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename E&amp;gt;
constexpr typename std::underlying_type&amp;lt;E&amp;gt;::type//C++11
//constexpr typename std::underlying_type_t&amp;lt;E&amp;gt;  //C++14
//constexpr auto                                //C++14
toUType(E enumerator) noexcept
{
return
static_cast&amp;lt;typename std::underlying_type&amp;lt;E&amp;gt;::type&amp;gt;(enumerator);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So &lt;code class=&quot;highlighter-rouge&quot;&gt;auto val = std::get&amp;lt;toUType(UserInfoFields::uiEmail)&amp;gt;(uInfo)&lt;/code&gt; replaces the above &lt;code class=&quot;highlighter-rouge&quot;&gt;static_cast&amp;lt;std::size_t&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-6&quot;&gt;conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• C++98-style enums are now known as unscoped enums.
• Enumerators of scoped enums are visible only within the enum. They convert
to other types only with a cast.
• Both scoped and unscoped enums support specification of the underlying type.
The default underlying type for scoped enums is int. Unscoped enums have no
default underlying type.
• Scoped enums may always be forward-declared. Unscoped enums may be
forward-declared only if their declaration specifies an underlying type.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;11-prefer-deleted-functions-to-private-undefined-ones&quot;&gt;11. Prefer deleted functions to private undefined ones&lt;/h1&gt;

&lt;p&gt;In C++98, declaring class member functions &lt;em&gt;private&lt;/em&gt; prevents clients(class objects) from calling them.
Deliberately failing to define them means that if code that still has access to them (i.e., member
functions or friends of the class) uses them, linking will fail due to missing function definition.&lt;/p&gt;

&lt;p&gt;In C++11, there’s a better way to achieve essentially the same end: use &lt;code class=&quot;highlighter-rouge&quot;&gt;= delete&lt;/code&gt; to
mark the copy constructor and the copy assignment operator as &lt;strong&gt;deleted functions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;An important advantage of deleted functions is that &lt;em&gt;any function&lt;/em&gt; may be deleted,
while only member functions may be private.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool isLucky(int number); // original function
bool isLucky(char) = delete; // reject chars
bool isLucky(bool) = delete; // reject bools
bool isLucky(double) = delete; // reject doubles and floats
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Delete a template instantiation inside a class:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// global template
template&amp;lt;typename T&amp;gt;
void processPointer(T* ptr);
template&amp;lt;&amp;gt;
void processPointer&amp;lt;void&amp;gt;(void*) = delete;
----------------------------------------
// class template functions
class Widget {
public:
...
template&amp;lt;typename T&amp;gt;
void processPointer(T* ptr)
{ ... }
...
};
template&amp;lt;&amp;gt;
void Widget::processPointer&amp;lt;void&amp;gt;(void*) = delete;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;template specializations must be written at namespace scope, not class scope.
They can be deleted outside the class(hence at namespace scope).&lt;/p&gt;

&lt;h2 id=&quot;conclusion-7&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Prefer deleted functions to private undefined ones.
• Any function may be deleted, including non-member functions and template
instantiations.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;12-declare-overriding-functions-override&quot;&gt;12. Declare overriding functions override&lt;/h1&gt;

&lt;p&gt;For overriding to occur, several requirments must be met:
• The base class function must be virtual.
• The base and derived function names must be identical (except in the case of
destructors).
• The parameter types of the base and derived functions must be identical.
• The constness of the base and derived functions must be identical.
• The return types and exception specifications of the base and derived functions
must be compatible.
• The functions’ reference qualifiers must be identical.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The last requirment points:
class Widget {
public:
...
void doWork() &amp;amp;; // this version of doWork applies only when *this is an lvalue
void doWork() &amp;amp;&amp;amp;; // this version of doWork applies only when *this is an rvalue
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A policy of using override on all your &lt;strong&gt;derived class&lt;/strong&gt; overrides can do more than just
enable compilers to tell you when would-be overrides aren’t overriding anything.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Base {
public:
virtual void mf1() const;
virtual void mf2(int x);
virtual void mf3() &amp;amp;;
virtual void mf4() const;
};
class Derived: public Base {
public:
virtual void mf1() const override;
virtual void mf2(int x) override;
virtual void mf3() &amp;amp; override;
void mf4() const override;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let me show you reference qualifiers:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
public:
using DataType = std::vector&amp;lt;double&amp;gt;;
...
DataType&amp;amp; data() &amp;amp;
{ return values; } // for lvalue Widgets, return lvalue
DataType data() &amp;amp;&amp;amp; // for rvalue Widgets, return rvalue
{ return std::move(values); }
...
private:
DataType values;
};
Widget w;
auto val1 = w.data();//calls lvalue overload for Widget::data, copy-constructs for val1
auto val2 = makeWidget().data();//calls rvalue overload for Widget::data, move-construct for val2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-8&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Declare overriding functions override.
• Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*this) differently.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;13-prefer-const_iterators-to-iterators&quot;&gt;13. Prefer const_iterators to iterators&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const_iterator&lt;/code&gt;s simply don’t convert to &lt;code class=&quot;highlighter-rouge&quot;&gt;iterator&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;C++11 added the &lt;strong&gt;non-member&lt;/strong&gt; function &lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;, but it failed to add &lt;code class=&quot;highlighter-rouge&quot;&gt;cbegin&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;rbegin&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;rend&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;crbegin&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;crend&lt;/code&gt;. For example, you can write non-memnber &lt;em&gt;cbegin&lt;/em&gt; youselves:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename C&amp;gt;
auto cbegin(const C&amp;amp; container)
-&amp;gt; decltype(std::begin(container))
{
	return std::begin(container);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In C++11, std::vector has member function &lt;em&gt;cbegin&lt;/em&gt; and &lt;em&gt;cend&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;//std::find
#include &amp;lt;vector&amp;gt;
#include &amp;lt;typeinfo&amp;gt;
#include &amp;lt;iterator&amp;gt;
int main(){
	std::vector&amp;lt;int&amp;gt; v{1,2,3,4,5};
	// auto ite is also OK
	std::vector&amp;lt;int&amp;gt;::const_iterator ite = std::find(v.cbegin(), v.cend(), 3);
	std::cout &amp;lt;&amp;lt; &quot;ite type is &quot; &amp;lt;&amp;lt; typeid(ite).name() &amp;lt;&amp;lt; std::endl;
	v.insert(ite, 2);
	for(auto &amp;amp;p: v)
		std::cout &amp;lt;&amp;lt; &quot;v is &quot; &amp;lt;&amp;lt; p &amp;lt;&amp;lt; std::endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you change compiler to C++14, the following is OK:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template &amp;lt;typename C, typename T&amp;gt;
void findAndInsert(C&amp;amp; container, const T&amp;amp; valueFind, const T&amp;amp; valueInsert)
{
	//non-member function
	auto place = std::find(std::cbegin(container), std::cend(container), valueFind);
	container.insert(place, valueInsert);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-9&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Prefer const_iterators to iterators.
• In maximally generic code, prefer non-member versions of begin, end,
rbegin, etc., over their member function counterparts.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;14-declare-functions-noexcept-if-they-wont-emit-exceptions&quot;&gt;14. Declare functions noexcept if they won’t emit exceptions&lt;/h1&gt;

&lt;h1 id=&quot;15-use-constexpr-whenever-possible&quot;&gt;15. Use constexpr whenever possible&lt;/h1&gt;

&lt;p&gt;Conceptually, constexpr indicates a value that’s not only constant, it’s known during compilation. I’ll just say that you can’t assume that the results of constexpr functions are const, nor can you take for granted that their values are known during compilation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;constexpr&lt;/em&gt; objects are, in fact, &lt;em&gt;const&lt;/em&gt;, have values at compile time. ((Technically, their values are
determined during translation, and translation consists not just of compilation but also of linking.)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 2;
const auto b = a; //find, b is const copy of a
constexpr auto c = a; //error, value not known at compilation time
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;all &lt;strong&gt;constexpr&lt;/strong&gt; objects are const, but not all &lt;strong&gt;const&lt;/strong&gt; objects are constexpr.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constexpr int pow(int base, int exp) noexcept {}
constexpr auto numConds = 5;
std::array&amp;lt;int, pow(3, numConds)&amp;gt; results; //std::array allocates memory at compilation time
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If &lt;em&gt;base&lt;/em&gt; and &lt;em&gt;exp&lt;/em&gt; are compile-time constants, &lt;code class=&quot;highlighter-rouge&quot;&gt;pow&lt;/code&gt;’s result may be used as a
compile-time constant. If base and/or exp are not compile-time constants, &lt;code class=&quot;highlighter-rouge&quot;&gt;pow&lt;/code&gt;’s
result will be computed at runtime.&lt;/p&gt;

&lt;p&gt;If params of constexpr functions can be specified at compilation time, them the function should
be computed at compilation time. C++11, constexpr member functions are implicitly const(const member functions
are forbidden &lt;em&gt;this).
And constexpr functions are limited to taking and returning *literal types&lt;/em&gt;. (void is not)&lt;/p&gt;

&lt;h2 id=&quot;conclusion-10&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• constexpr objects are const and are initialized with values known during
compilation.
• constexpr functions can produce compile-time results when called with
arguments whose values are known during compilation.
• constexpr objects and functions may be used in a wider range of contexts
than non-constexpr objects and functions.
• constexpr is part of an object’s or function’s interface.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;16-make-const-member-functions-thread-safe&quot;&gt;16. Make const member functions thread safe&lt;/h1&gt;

&lt;p&gt;Operations on &lt;code class=&quot;highlighter-rouge&quot;&gt;std::atomic&lt;/code&gt; variables are often less expensive than &lt;strong&gt;mutex acquisition and release&lt;/strong&gt;, you may be tempted to lean on std::atomics more heavily than you should.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Point { // 2D point
public:
...
double distanceFromOrigin() const noexcept
{
	++callCount; // atomic increment
	return std::sqrt((x * x) + (y * y));
}
private:
	mutable std::atomic&amp;lt;unsigned&amp;gt; callCount{ 0 };
	double x, y;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There’s a lesson here. For a single variable or memory location requiring synchroni‐
zation, use of a std::atomic is adequate, but once you get to two or more variables
or memory locations that require manipulation as a unit, you should reach for a
mutex.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
public:
...
int magicValue() const
{
std::lock_guard&amp;lt;std::mutex&amp;gt; guard(m);// lock m
if (cacheValid) return cachedValue;
else {
	auto val1 = expensiveComputation1();
	auto val2 = expensiveComputation2();
	cachedValue = val1 + val2;
	cacheValid = true;
	return cachedValue;
			}
}// unlock m
...
private:
mutable std::mutex m;
mutable int cachedValue; // no longer atomic
mutable bool cacheValid{ false }; // no longer atomic
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-11&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Make const member functions thread safe unless you’re certain they’ll never
be used in a concurrent context.
• Use of std::atomic variables may offer better performance than a mutex, but
they’re suited for manipulation of only a single variable or memory location.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;17-understand-special-member-function-generation-generation-of-the-copy-operations-in-classes-with-an-explicitly&quot;&gt;17. Understand special member function generation (Generation of the copy operations in classes with an explicitly&lt;/h1&gt;
&lt;p&gt;declared destructor is deprecated?)&lt;/p&gt;

&lt;p&gt;C++98 has four such functions: the default constructor, the destructor, the copy constructor, and the copy assignment operator.&lt;/p&gt;

&lt;p&gt;Generated special member functions are implicitly public and inline.(Normal member functions written outside the space of class are not inline.)
A destructor in a derived class inheriting from a base class with a virtual destructor is a virtual function.&lt;/p&gt;

&lt;p&gt;C++11, the special member functions club has two more inductees: the move constructor and the move assignment operator.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
public:
Widget(Widget&amp;amp;&amp;amp; rhs); // move constructor
Widget&amp;amp; operator=(Widget&amp;amp;&amp;amp; rhs); // move assignment operator
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;The move operations perform “&lt;strong&gt;memberwise moves&lt;/strong&gt;” on the non-static data members of the class.&lt;/li&gt;
  &lt;li&gt;The move assignment operator move-assigns each non-static data member and base class parts from its parameter.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Simply remember that a &lt;em&gt;default memberwise move&lt;/em&gt; consists of move operations on data members and base classes that support move operations, but a copy operation for those that don’t.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;self-defined-move-member-functions&quot;&gt;self-defined move member functions&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;The two copy operations are independent: declaring one doesn’t prevent compilers from generating the other. The two move operations are not independent. If you declare either, that prevents compilers from generating the other.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you declare, say, a move constructor for your class, you’re indicating that there’s something about how move
construction should be implemented that’s different from the &lt;strong&gt;default memberwise move&lt;/strong&gt; that &lt;em&gt;compilers would generate&lt;/em&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Furthermore, move operations (construction or assignment) won’t be generated for any class if explicitly declaring a copy operation.
The justification is that declaring a copy operation indicates that the normal approach to copying an object
isn’t appropriate for the class. Compiler figures that &lt;em&gt;memberwise move&lt;/em&gt; is not as appropriate as &lt;em&gt;memberwise copy&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Declaring a move operation (construction or assignment) in a class causes compilers to disable the copy operations, too.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In C++98/11, the existence of a user-declared destructor had no impact on compilers’ willingness to generate copy operations. But C++11
realise user-declared destructor means different memory management. So user-declared destructor will stop generating move operations.&lt;/p&gt;

&lt;p&gt;In C++11(C++98 no move operations), move operations are generated for classes (when needed) only if these three things are true:&lt;/p&gt;

&lt;p&gt;• No copy operations are declared in the class.
• No move operations are declared in the class.
• No destructor is declared in the class.&lt;/p&gt;

&lt;p&gt;Polymorphic base classes normally have virtual destructors&lt;/p&gt;

&lt;p&gt;Declaring a destructor has a potentially significant side effect: it prevents the move operations from being generated. However, creation of
the class’s copy operations is unaffected. requests to move it will compile and run. Such requests will cause copies to be made.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-12&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• The special member functions are those compilers may generate on their own:
default constructor, destructor, copy operations, and move operations.
• Move operations are generated only for classes lacking explicitly declared
move operations, copy operations, and a destructor.
• The copy constructor is generated only for classes lacking an explicitly
declared copy constructor, and it’s deleted if a move operation is declared.
The copy assignment operator is generated only for classes lacking an explicitly declared
copy assignment operator, and it’s deleted if a move operation is declared. Generation of
the copy operations in classes with an explicitly declared destructor is deprecated.
• Member function templates never suppress generation of special member
functions.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;use-stdunique_ptr-for-exclusive-ownership-resource-management&quot;&gt;Use std::unique_ptr for exclusive-ownership resource management.&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&lt;/code&gt;(唯一) is a move-only type pointer.&lt;/p&gt;

&lt;p&gt;Attempting to assign a raw pointer (e.g., from new) to a std::unique_ptr won’t compile, because it would constitute an implicit conversion from a raw to a smart pointer. Such implicit conversions can be problematic.&lt;/p&gt;

&lt;h2 id=&quot;stdunique_ptr-size&quot;&gt;std::unique_ptr size&lt;/h2&gt;

&lt;p&gt;when using the default deleter (i.e., delete), you can reasonably assume that std::unique_ptr objects are the same size as &lt;em&gt;raw pointers&lt;/em&gt;. When
custom deleters(自定义) enter the picture, this may no longer be the case. std::unique_ptr typically grows up to two words from one. For example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto delInvmt1 = [](Investment* pInvestment) //custom deleter as stateless lambda
{
	makeLogEntry(pInvestment);
	delete pInvestment;
};
template&amp;lt;typename... Ts&amp;gt;
std::unique_ptr&amp;lt;Investment, decltype(delInvmt1)&amp;gt;
makeInvestment(Ts&amp;amp;&amp;amp;... args); // return type has size of Investment*
-------------------------------------------
void delInvmt2(Investment* pInvestment) //custom deleter as function
{
	makeLogEntry(pInvestment);
	delete pInvestment;
} // custom deleter as function
template&amp;lt;typename... Ts&amp;gt;
std::unique_ptr&amp;lt;Investment, void (*)(Investment*)&amp;gt; // return type has size of Invectment*
makeInvestment(Ts&amp;amp;&amp;amp;... params); //  plus at least size of function pointer!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;stdunique_ptr-format&quot;&gt;std::unique_ptr format&lt;/h2&gt;

&lt;p&gt;std::unique_ptr comes in two forms, one for individual objects (&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;) and one for arrays (&lt;code class=&quot;highlighter-rouge&quot;&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;).
About the only situation I can conceive of when a std::unique_ptr&amp;lt;T[]&amp;gt; would make sense would be when you’re using a &lt;strong&gt;C-like&lt;/strong&gt; API that returns a raw pointer to a &lt;em&gt;heap array&lt;/em&gt; that you assume ownership of.&lt;/p&gt;

&lt;p&gt;it easily and efficiently converts to a std::shared_ptr:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::shared_ptr&amp;lt;Investment&amp;gt; sp = makeInvestment( arguments ); // converts std::unique_ptr to std::shared_ptr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is a key part of why std::unique_ptr is so well suited as a factory function return type. Factory functions can’t know whether callers will want to use exclusive-ownership semantics for the object they return or whether shared ownership (i.e., std::shared_ptr) would be more appropriate.&lt;/p&gt;

&lt;h2 id=&quot;factory-functions&quot;&gt;factory functions&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// a simple factory function
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;
class Cup
{
    public:
        Cup()
          : color(&quot;&quot;)
        {}
        std::string color;
        /* This is the factory method. */
        static std::unique_ptr&amp;lt;Cup&amp;gt; getCup(std::string color);
};
class RedCup : public Cup
{
    public:
        RedCup()
        {
            color = &quot;red&quot;;
        }
};
class BlueCup : public Cup
{
    public:
        BlueCup()
        {
            color = &quot;blue&quot;;
        }
};
std::unique_ptr&amp;lt;Cup&amp;gt; Cup::getCup(std::string color)
{
    if (color == &quot;red&quot;)
        return std::unique_ptr&amp;lt;Cup&amp;gt;(new RedCup());
    else if (color == &quot;blue&quot;)
        return std::unique_ptr&amp;lt;Cup&amp;gt;(new BlueCup());
    else
        return 0;
}
/* A little testing */
int main()
{
    /* Now we decide the type of the cup at
       runtime by the factory method argument */
    std::unique_ptr&amp;lt;Cup&amp;gt; redCup  = Cup::getCup(&quot;red&quot;);
    std::cout &amp;lt;&amp;lt; redCup-&amp;gt;color &amp;lt;&amp;lt; std::endl;

    std::unique_ptr&amp;lt;Cup&amp;gt; blueCup = Cup::getCup(&quot;blue&quot;);
    std::cout &amp;lt;&amp;lt; blueCup-&amp;gt;color &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion-13&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• std::unique_ptr is a small, fast, move-only smart pointer for managing
resources with exclusive-ownership semantics.
• By default, resource destruction takes place via delete, but custom deleters can be specified.
Stateful deleters and function pointers as deleters increase the size of std::unique_ptr objects.
• Converting a std::unique_ptr to a std::shared_ptr is easy.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;19-use-stdshared_ptr-for-shared-ownership-resource-management&quot;&gt;19. Use std::shared_ptr for shared-ownership resource management&lt;/h1&gt;

&lt;p&gt;A simple example about shared_ptr reference count: If sp1 and sp2 are std::shared_ptrs to different objects, the assignment “sp1 = sp2;” modifies sp1 such that it points to the object pointed to by sp2. The net effect of the assignment is that the reference count for the object originally pointed to by sp1 is decremented, while that for the object pointed to by sp2 is incremented. If a std::shared_ptr sees a reference count of zero after performing a decrement, no more std::shared_ptrs point to the resource, so the std::shared_ptr destroys it.&lt;/p&gt;

&lt;h2 id=&quot;characteristic-of-shared_ptr&quot;&gt;characteristic of shared_ptr&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;std::shared_ptrs are twice the size of a raw pointer.&lt;/li&gt;
  &lt;li&gt;Memory for the reference count must be dynamically allocated.&lt;/li&gt;
  &lt;li&gt;Increments and decrements of the reference count must be atomic.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is as true for assignment as for construction, so move construction is faster than copy construction, and move
assignment is faster than copy assignment. Because no reference count manipulation is required. Regardless of deleter, a
std::shared_ptr object is two pointers(pointers to object T and to control block) in size.&lt;/p&gt;

&lt;h2 id=&quot;distinguish-between-unique_ptr-and-shared_ptr&quot;&gt;distinguish between unique_ptr and shared_ptr&lt;/h2&gt;

&lt;p&gt;The type of the deleter is part of the type of the unique_ptr, but shared_ptr is not. Another difference is specifying a custom deleter doesn’t
change the size of a std::shared_ptr object. It can change unique_ptr size notwithstanding.&lt;/p&gt;

&lt;h2 id=&quot;shared_ptr-format&quot;&gt;shared_ptr format&lt;/h2&gt;

&lt;p&gt;An object’s control block is set up by the function creating the first &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&lt;/code&gt; to the object.&lt;/p&gt;

&lt;p&gt;In general, it’s impossible for a function creating a std::shared_ptr to an object to know whether some other std::shared_ptr already points to that object, so the following rules for control block creation are used:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;std::make_shared (see Item 21) always creates a control block.&lt;/li&gt;
  &lt;li&gt;A control block is created when a std::shared_ptr is constructed from a unique-ownership pointer.&lt;/li&gt;
  &lt;li&gt;When a std::shared_ptr constructor is called with a raw pointer, it creates a control block&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you wanted to create a std::shared_ptr from an object that already had a control block, you’d presumably pass a std::shared_ptr or a
std::weak_ptr (see Item 20) as a constructor argument, not a raw pointer or a unique_ptr.&lt;/p&gt;

&lt;p&gt;A consequence of these rules is that constructing more than one std::shared_ptr from a single raw pointer gives you a complimentary ride on the particle accelerator of undefined behavior, because the pointed-to object will have multiple control blocks. Multiple control blocks means multiple reference counts, and multiple reference counts means the object will be destroyed multiple times (once for each reference count).&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto loggingDel = [](Widget *pw)
{
std::cout &amp;lt;&amp;lt; &quot;destruct\n&quot;;
delete pw;
};
Widget* pw = new Widget;
std::shared_ptr&amp;lt;Widget&amp;gt; spw1(pw, loggingDel);
std::shared_ptr&amp;lt;Widget&amp;gt; spw2(pw, loggingDel);
&amp;gt;&amp;gt; destruct
&amp;gt;&amp;gt; destruct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So try to avoid passing raw pointers to a std::shared_ptr constructor. The usual alternative is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;std::make_share&lt;/code&gt;. Or pass the result of new directly instead of going through a raw pointer variable. Like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw1(new Widget, loggingDel)&lt;/code&gt;.
The instance is using raw points &lt;em&gt;*this&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
public:
void process(){
	//create new control block for each this
	processedWidgets.emplace_back(this);
}
};
---------------------------------------------
class Widget: public std::enable_shared_from_this&amp;lt;Widget&amp;gt;{
public:
void process(){
	//enable_shared_from_this is template base class
	//std::enable_shared_from_this defines a member
	//function that creates a std::shared_ptr to the
	//current object, but it does it without duplicating control
	//blocks. The member function is shared_from_this.
	processedWidgets.emplace_back(shared_from_this());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shared_from_this&lt;/code&gt; looks up the control block for the current object, and it creates a new &lt;em&gt;std::shared_ptr&lt;/em&gt; that refers to that control block.
For that to be the case, there must be an existing std::shared_ptr. To prevent clients from calling member functions that invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;shared_from_this&lt;/code&gt;
before a &lt;em&gt;std::shared_ptr&lt;/em&gt; points to the object, the above code is changed to:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget: public std::enable_shared_from_this&amp;lt;Widget&amp;gt; {
public:
	// factory function that perfect-forwards args to a private ctor
	template&amp;lt;typename... Ts&amp;gt;
	static std::shared_ptr&amp;lt;Widget&amp;gt; create(Ts&amp;amp;&amp;amp;... params);
	void process();
private:
	// ...  ctor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;std::shared_ptr implementation is more sophisicated thant you can expect, which may include dynamically allocated control blocks, arbitrarily large deleters and allocators, virtual function machinery(when the object is destroyed), and atomic reference count manipulations.&lt;/p&gt;

&lt;p&gt;There’s no std::shared_ptr&amp;lt;T[]&amp;gt; but std::unique_ptr&amp;lt;T[]&amp;gt; is OK.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-14&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• std::shared_ptrs offer convenience approaching that of garbage collection
for the shared lifetime management of arbitrary resources.
• Compared to std::unique_ptr, std::shared_ptr objects are typically
twice as big, incur overhead for control blocks, and require atomic reference
count manipulations.
• Default resource destruction is via delete, but custom deleters are supported.
The type of the deleter has no effect on the type of the std::shared_ptr.
• Avoid creating std::shared_ptrs from variables of raw pointer type.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;20-use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle&quot;&gt;20. Use std::weak_ptr for std::shared_ptr like pointers that can dangle&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Pointer dangling&lt;/em&gt; is that what it points to has been destroyed.&lt;/p&gt;

&lt;p&gt;std::weak_ptrs can’t be dereferenced, nor can they be tested for nullness. It’s an augmentation of std::shared_ptr.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto pw = std::make_shared&amp;lt;Widget&amp;gt;(); //reference count is 1
std::weak_ptr&amp;lt;Widget&amp;gt; wp(pw); //weak_ptr is created from shared_ptr,reference count is still 1
pw = nullptr; //RC goes to 0, Widget is destroyed. pw now dangles.
if (wpw.expired()) //
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One form is std::weak_ptr::lock, which returns a std::shared_ptr. The std::shared_ptr is null if the std::weak_ptr has
expired:&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw1 = wpw.lock()&lt;/code&gt;; The other form is the std::shared_ptr constructor taking a std::weak_ptr as an
argument. In this case, if the std::weak_ptr has expired, an exception is thrown:&lt;code class=&quot;highlighter-rouge&quot;&gt;std::shared_ptr&amp;lt;Widget&amp;gt; spw3(wpw)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;observer-design-pattern&quot;&gt;Observer design pattern&lt;/h2&gt;

&lt;p&gt;The primary components of this pattern are subjects(object whose state may change) and observers(objects to be notified when state changes occur).&lt;/p&gt;

&lt;p&gt;A reasonable design is for each subject to hold a container of std::weak_ptrs to its observers, thus making it possible for the subject to determine
whether a pointer dangles before using it. It is that weak_ptr is used to check whether the pointed objects exist.&lt;/p&gt;

&lt;h2 id=&quot;weak_ptr-size&quot;&gt;weak_ptr size&lt;/h2&gt;

&lt;p&gt;std::weak_ptr objects are the same size as std::shared_ptr objects, they make use of the same control blocks as std::shared_ptrs. Remember weak_ptr doesn’t participate shared ownership of objects and hence don’t affect the pointed-to object’s reference count.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-15&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.
• Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;21-prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new&quot;&gt;21. Prefer std::make_unique and std::make_shared to direct use of new&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;std::make_unique&lt;/em&gt; is included in C++14, &lt;em&gt;std::make_shared&lt;/em&gt; is included in C++11. Hence, you can do it yourself in C++11(This form of the function
doesn’t support arrays or custom deleters):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T, typename... Ts&amp;gt;
std::unique_ptr&amp;lt;T&amp;gt; make_unique(Ts&amp;amp;&amp;amp;... params)
{
	return std::unique_ptr&amp;lt;T&amp;gt;(new T(std::forward&amp;lt;Ts&amp;gt;(params)...));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The third make function is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::allocate_shared&lt;/code&gt; for dynamic memory allocation. You can unleash your Google engine if you want to know it.&lt;/p&gt;

&lt;h2 id=&quot;tidy-and-safe-new-a-shared_ptr&quot;&gt;tidy and safe new a shared_ptr&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int computePriority();
void processWidget(std::shared_ptr&amp;lt;Widget&amp;gt; spw, int priority);
processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), computePriority()); //potential resource leak
processWidget(std::make_shared&amp;lt;Widget&amp;gt;(), computePriority()); //no potential resource leak
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If we replace std::shared_ptr and std::make_shared with std::unique_ptr and std::make_unique, exactly the same reasoning applies.&lt;/p&gt;

&lt;h2 id=&quot;distinguish-between-new-and-make_shared&quot;&gt;distinguish between new and make_shared&lt;/h2&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;memory allocation
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// requires one memory allocation for the Widget
// and a second allocation for the control block.
std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget);
// a single chunk of memory to hold both the
// Widget object and the control block
auto spw = std::make_shared&amp;lt;Widget&amp;gt; ();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;None of the make functions permit the specification of custom deleters. There’s no way to do the same (following) thing with a make function.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::unique_ptr&amp;lt;Widget, decltype(widgetDeleter)&amp;gt; upw(new Widget, widgetDeleter);
std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget, widgetDeleter);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Because braced initializers can’t be perfect-forwarded. &lt;strong&gt;make&lt;/strong&gt; functions do not support braces “{}” you must use &lt;strong&gt;new&lt;/strong&gt; directly. But there is always a workaround:
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// create std::initializer_list
auto initList = { 10, 20 };
// create std::vector using std::initializer_list ctor
auto spv = std::make_shared&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(initList);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Using make functions to create objects of types with class-specific versions of operator new and operator delete is typically a poor idea.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;The size and speed disadvantages of std::make_shared&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The reference count tracks how many &lt;em&gt;std::shared_ptr&lt;/em&gt;s refer to the control block. The second reference count(weak count) tallies how many &lt;em&gt;std::weak_ptr&lt;/em&gt;s refer to the control block. (&lt;em&gt;weak_ptr&lt;/em&gt; checks the reference count to make sure whether std::shared_ptr needs to be destroyed)
If new produces memory alocation, then shared_ptr to object will destroyed when reference count is 0. But std::weak_ptrs to it remain. One of two allocated memory is released(object block), the other(control block) will wait until weak_ptr to objects is destroyed.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-16&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• Compared to direct use of new, make functions eliminate source code duplication, improve exception safety, and, for std::make_shared and std::allocate_shared, generate code that’s smaller and faster.
• Situations where use of make functions is inappropriate include the need to specify custom deleters and a desire to pass braced initializers.
• For std::shared_ptrs, additional situations where make functions may be ill-advised include (1) classes with custom memory management and (2) systems with memory concerns, very large objects, and std::weak_ptrs that outlive the corresponding std::shared_ptrs.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;22-when-using-the-pimpl-idiom-define-special-member-functions-in-the-implementation-file&quot;&gt;22. When using the Pimpl Idiom, define special member functions in the implementation file&lt;/h1&gt;

&lt;p&gt;The Pimpl Idiom is a way to reduce compilation dependencies between a class’s implementation and the class’s clients, but, conceptually, use of the idiom doesn’t change what the class represents.&lt;/p&gt;

&lt;p&gt;If member variables has unique_ptr or something which can not be copyed and moved only, move ctor should typically written down explicitly. If copy and copy assignment are adopted, deep copy should be operated:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// declare only in .h
// class Widget has two member variables:
// struct Impl; std::unique_ptr&amp;lt;Impl&amp;gt; pImpl;
Widget(const Widget&amp;amp; rhs);
Widget&amp;amp; operator=(const Widget&amp;amp; rhs);
// definition in .cpp
Widget::Widget(const Widget&amp;amp; rhs)
: pImpl(std::make_unique&amp;lt;Impl&amp;gt;(*rhs.pImpl))
{} // copy ctor
Widget&amp;amp; Widget::operator=(const Widget&amp;amp; rhs)
{
*pImpl = *rhs.pImpl;
return *this;
} // copy operator=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above, we simply copy the fields of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Impl&lt;/code&gt; struct from the source object (rhs) to the destination object (*this). We take advantage of the fact that compilers will create the copy operations for &lt;code class=&quot;highlighter-rouge&quot;&gt;Impl&lt;/code&gt;, and these operations will copy each field automatically.&lt;/p&gt;

&lt;p&gt;{class_name} client points .h and {class_name} implementation points .cpp.&lt;/p&gt;

&lt;p&gt;In PImpl, A consequence of unique_ptr’s greater efficiency is that pointed-to types must be complete when compiler-generated special functions (e.g.,
destructors or move operations) are used. So destructor need to be written. For std::shared_ptr, the type of the deleter is not part of the type of the smart pointer. This necessitates larger runtime data structures and somewhat slower code, but pointed-to types need not be complete when compiler-generated special functions are employed.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-17&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• The Pimpl Idiom decreases build times by reducing compilation dependencies between class clients and class implementations.
• For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file. Do this even
if the default function implementations are acceptable.
• The above advice applies to std::unique_ptr, but not to std::shared_ptr.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;23-understand-stdmove-and-stdforward&quot;&gt;23. Understand std::move and std::forward&lt;/h1&gt;

&lt;h2 id=&quot;what-is-lvalue-and-rvalue&quot;&gt;What is lvalue and rvalue&lt;/h2&gt;

&lt;p&gt;A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is. If you can’t, it’s usually an rvalue. It’s especially important to remember this when dealing with a parameter of rvalue reference type, because the parameter itself is an lvalue:&lt;code class=&quot;highlighter-rouge&quot;&gt;Widget(Widget&amp;amp;&amp;amp; rhs)&lt;/code&gt;. rhs is an lvalue, though it has rvalue reference type.&lt;/p&gt;

&lt;h2 id=&quot;move-and-perfect-forward&quot;&gt;move and perfect forward&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;std::move&lt;/em&gt; unconditionally casts its argument to an rvalue, while &lt;em&gt;std::forward&lt;/em&gt; performs this cast only if a particular condition is fulfilled.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; // in namespace std C++11
typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; param)
{
	using ReturnType = // alias declaration;
	typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;;
	return static_cast&amp;lt;ReturnType&amp;gt;(param);
}
-------------------------------------
template&amp;lt;typename T&amp;gt;
// C++14; still in namespace std
decltype(auto) move(T&amp;amp;&amp;amp; param)
{
	using ReturnType = remove_reference_t&amp;lt;T&amp;gt;&amp;amp;&amp;amp;;
	return static_cast&amp;lt;ReturnType&amp;gt;(param);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;std::move&lt;/em&gt; casts its argument to an rvalue, and that’s all it does. Moving a value out of an objet generally modifies the object, so the language should not permit &lt;strong&gt;const&lt;/strong&gt; objects to be passed to functions(such as move constructors) that could modify them.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------use string as member----------
class Annotation {
public:
explicit Annotation(const std::string text)
: value(std::move(text)) // &quot;move&quot; text into value; this code doesn't do what it seems to!
private:
		std::string value;
};
---------string class ctor------------
class string{
public:
		string(const string&amp;amp;); // copy ctor
		string(string&amp;amp;&amp;amp;); // move ctor
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above &lt;em&gt;text&lt;/em&gt; is not moved into value, it’s &lt;strong&gt;copied&lt;/strong&gt;. An rvalue of type &lt;em&gt;const std::string&lt;/em&gt; can’t be passed to std::string’s move constructor, because the move constructor takes an rvalue reference to a &lt;em&gt;non-const std::string&lt;/em&gt;. The rvalue can, however, be passed to the copy constructor, because an &lt;em&gt;lvalue-reference-to-const&lt;/em&gt; is permitted to bind to a &lt;em&gt;const rvalue&lt;/em&gt;. The member initialization therefore invokes &lt;em&gt;the copy constructor&lt;/em&gt; in std::string, even though text has been cast to an rvalue! Such behavior is essential to maintaining &lt;em&gt;const-correctness&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The most common scenario is a function template taking a universal reference parameter that is to be passed to another function:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void process(const Widget&amp;amp; lvalArg); // process lvalues
void process(Widget&amp;amp;&amp;amp; rvalArg);// process rvalues
template&amp;lt;typename T&amp;gt;					// template that passes
void logAndProcess(T&amp;amp;&amp;amp; param)// param to process
{
auto now = std::chrono::system_clock::now();
makeLogEntry(&quot;Calling 'process'&quot;, now);
process(std::forward&amp;lt;T&amp;gt;(param));
}
----------------implementation------------------
Widget w;
logAndProcess(w); // call with lvalue
logAndProcess(std::move(w)); // call with rvalue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the above code, the &lt;strong&gt;param&lt;/strong&gt; is always lvalue in &lt;em&gt;logAndProcess&lt;/em&gt; function, so can not transform param to &lt;em&gt;process&lt;/em&gt; function directly. We adopt *std::forward&lt;T&gt;()*. That’s why std::forward is a conditional cast: it casts to an rvalue only if its argument was initialized with an rvalue. Whether
param was initialized with an lvalue or an rvalue is encoded in **logAndProcess**’s template parameter **T**.&lt;/T&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion-18&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;				Things to Remember
• std::move performs an unconditional cast to an rvalue. In and of itself, it doesn’t move anything.
• std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.
• Neither std::move nor std::forward do anything at runtime.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;24-distinguish-universal-references-from-rvalue-references&quot;&gt;24. Distinguish universal references from rvalue references&lt;/h1&gt;

&lt;h2 id=&quot;not-a-universal-reference&quot;&gt;not a universal reference&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void f(const T&amp;amp;&amp;amp; param); // param is an rvalue reference
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That’s because being in a template doesn’t guarantee the presence of type deduction.&lt;/p&gt;

&lt;h2 id=&quot;vector-type-deduction&quot;&gt;vector type deduction&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;----------------push_back(rvalue)---------------------------
template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt;
class vector {
public:
void push_back(T&amp;amp;&amp;amp; x); //rvalue reference, no type deduction
...
};
----------------emplace_back(universal reference)-------------
template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt;
class vector {
public:
template &amp;lt;class... Args&amp;gt;
void emplace_back(Args&amp;amp;&amp;amp;... args); // universal reference
...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;push_back&lt;/em&gt; can’t exist without a particular vector instantiation for it to be part of, and the type of that instantiation fully determines the declaration for &lt;em&gt;push_back&lt;/em&gt;. In &lt;em&gt;emplace_back&lt;/em&gt;, the type parameter &lt;em&gt;Args&lt;/em&gt; is independent of vector’s type parameter T, so &lt;em&gt;Args&lt;/em&gt; must be deduced each time &lt;em&gt;emplace_back&lt;/em&gt; is called.&lt;/p&gt;

&lt;p&gt;Variables declared with the type &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; (typically C++14) are universal references, because type deduction takes place and they have the correct form (“&lt;strong&gt;T&amp;amp;&amp;amp;&lt;/strong&gt;”).&lt;/p&gt;

&lt;h2 id=&quot;conclusion-19&quot;&gt;Conclusion&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;			Things to Remember
• If a function template parameter has type T&amp;amp;&amp;amp; for a deduced type T, or if an object is declared using auto&amp;amp;&amp;amp;, the parameter or object is a universal reference.
• If the form of the type declaration isn’t precisely type&amp;amp;&amp;amp;, or if type deduction does not occur, type&amp;amp;&amp;amp; denotes an rvalue reference.
• Universal references correspond to rvalue references if they’re initialized with rvalues. They correspond to lvalue references if they’re initialized with lvalues.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;25-use-stdmove-on-rvalue-references-stdforward-on-universal-references&quot;&gt;25. Use std::move on rvalue references, std::forward on universal references.&lt;/h1&gt;

&lt;p&gt;In short, rvalue references should be unconditionally cast to rvalues (via std::move) when forwarding them to other functions, because they’re always bound to rvalues, and universal references should be conditionally cast to rvalues (via std::forward) when forwarding them, because they’re only sometimes bound to rvalues.&lt;/p&gt;

&lt;h2 id=&quot;move-meaning&quot;&gt;move meaning&lt;/h2&gt;

&lt;p&gt;If I use &lt;em&gt;std::move&lt;/em&gt; to universal reference, n has undefined behavior:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------code-------------------
#include &amp;lt;memory&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;
class Widget {
public:
template&amp;lt;typename T&amp;gt;
void setName(T&amp;amp;&amp;amp; newName)
{ name = std::move(newName); }
private:
    std::string name;
    std::shared_ptr&amp;lt;int&amp;gt; p;
};
std::string getWidgetName(){
    const std::string str = &quot;whatthehell&quot;;
    return str;
}
int main(){
    Widget w;
    auto n = getWidgetName(); // n is local variable
    std::cout &amp;lt;&amp;lt; &quot;n is &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
    w.setName(n);
    std::cout &amp;lt;&amp;lt; &quot;n is &quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl;
}
------------------result------------------
n is whatthehell
n is
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;template-member-function-of-universal-reference&quot;&gt;template member function of universal reference&lt;/h2&gt;

&lt;p&gt;The string literal “Adela Novak” would be passed to &lt;em&gt;setName&lt;/em&gt;, where it would be conveyed to the assignment operator for the &lt;em&gt;std::string&lt;/em&gt; inside &lt;em&gt;w&lt;/em&gt;. &lt;em&gt;w&lt;/em&gt;’s name data member would thus be assigned directly from the string literal. With the overloaded versions of setName, however, a temporary &lt;em&gt;std::string&lt;/em&gt; object would be created for &lt;em&gt;setName&lt;/em&gt;’s parameter to bind to, and this temporary &lt;em&gt;std::string&lt;/em&gt; would then be moved into w’s data member.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--------------template universal ctor----------------
class Widget {
public:
template&amp;lt;typename T&amp;gt;
void setName(T&amp;amp;&amp;amp; newName) // newName is universal reference
{ name = std::forward&amp;lt;T&amp;gt;(newName); }
...
};
---------------a pair ctor------------------
class Widget {
public:
void setName(const std::string&amp;amp; newName)// set from const lvalue
{ name = newName; }
void setName(std::string&amp;amp;&amp;amp; newName) // set from rvalue
{ name = std::move(newName); }
...
};
--------------implementation--------------------
w.setName(&quot;Adela Novak&quot;); // use std::string&amp;amp;&amp;amp;
w.setName(std::move(getWidgetName()); // if getWidgetName return const std::string, then use const std::string&amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The real and serious problem with overloading of rvalue and lvalue is poor scalability of the design. If we have unlimited params, how to make overloading for each param. The following (universal references) is the best and only way to solve the problem.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;class T, class... Args&amp;gt;
shared_ptr&amp;lt;T&amp;gt; make_shared(Args&amp;amp;&amp;amp;... args);//不定参数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Remember that apply &lt;code class=&quot;highlighter-rouge&quot;&gt;std::move&lt;/code&gt; (for rvalue references) or &lt;code class=&quot;highlighter-rouge&quot;&gt;std::forward&lt;/code&gt; (for universal references) to only the &lt;strong&gt;final&lt;/strong&gt; use of the reference.&lt;/p&gt;

&lt;h2 id=&quot;return-local-variable-by-value&quot;&gt;return local variable by value&lt;/h2&gt;

&lt;p&gt;Compilers may elide the copying (or moving) of a local object 2 in a function that returns by value&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/28/effective-cpp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/28/effective-cpp/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Cross Obstables</title>
        <description>&lt;p&gt;&lt;strong&gt;浮生如梦&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;all-in-all&quot;&gt;All in all&lt;/h2&gt;

&lt;p&gt;In words, control of the car is not accurate, planning of the car is not complete, and perspection of the car is not applicable.&lt;/p&gt;

&lt;p&gt;First of all, the control algorithm or excutive agencies may have latency problems which result from vehicle classis. And then, planning module lacks global planning, contains only local planning. The current methods of planning is solely suitable for closed road environment and not sparse RNDF. Both of them are missing in this game, so the game has not started but has finished. The failure is destined. Finally, the behavior of hitting trees is abnormal for UVCs, for which perspection of the car is responbible. It tells us that it is not sensible to depend on sole sensor giving up multi-sensor fusion. For detecting accessible areas of cars, which is so important that the car moving relys heavily on, at least two different sensors produce accessible areas. At the same time, different algorithms are used to the same sensors to realize different results. Multi-source sensors fusion results in sophisticated system integration. That makes us need more time to consume others’ algorithm. It proves that system integration is not a simple problem of “1+1”.&lt;/p&gt;

&lt;p&gt;When results of multi-source sensors conflict with each other, how to fuse them to unified and wonderful result better than unique sensor. Or we can do fusion to a deeper degree, for example, fuse lasers and cameras data and then do clustering or segmentation.&lt;/p&gt;

&lt;h2 id=&quot;in-future&quot;&gt;In future&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Add global planning module. Replace current text saving RNDF with GUI and third part API. The tool needs to manipulate map data quickly. Especially, it needs contain map mathcing for GPS points, such as QGIS.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I should be familar with Kalman Filter from functions in OpenCV. KF is useful in multi-frame detection and tracking.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The final problem is Scene Understanding for UVCs. It may come true via fusing multi-cameras even add laser data. I have no thoughts for now.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/19/cross-obstacles/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/19/cross-obstacles/</guid>
        
        <category>个人总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Eigen LIB</title>
        <description>&lt;h2 id=&quot;transform&quot;&gt;Transform&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::Vector3f trans_vec_A;
//note that you have to create a Translation because multiplying a 
//Transform with a vector will _apply_ the transform to the vector
Eigen::Translation&amp;lt;float,3&amp;gt; translation_A(trans_vec_A);
Eigen::Quaternionf rotation_B;
Eigen::Quaternionf rotation_C;
Eigen::Quaternionf rotation_D;
Eigen::Vector3f trans_vec_E;
Eigen::Translation&amp;lt;float,3&amp;gt; translation_E(trans_vec_E);
Eigen::Transform&amp;lt;float,3,Affine&amp;gt; combined = 
      translation_A * rotation_B * rotation_C * rotation_D * translation_E;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;{Note that} &lt;code class=&quot;highlighter-rouge&quot;&gt;combined = A*B*C*D*E&lt;/code&gt;, so combined applied to a &lt;em&gt;vector v&lt;/em&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;combined*v = A*B*C*D*E*v = A*(B*(C*(D*(E*v))))&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 04 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/09/04/eigen-lib/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/09/04/eigen-lib/</guid>
        
        <category>理论梳理</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>YAML-CPP</title>
        <description>&lt;p&gt;##安装&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;github网站下载，编译成库文件&lt;/li&gt;
  &lt;li&gt;安装ros后就安装了yaml-cpp&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;读yaml文件&quot;&gt;读yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;fstream&amp;gt; 
#include &amp;lt;string&amp;gt;
#include &quot;yaml-cpp/yaml.h&quot;
template&amp;lt;typename T&amp;gt;
void operator &amp;gt;&amp;gt; (const YAML::Node&amp;amp; node, T&amp;amp; i)  //最新的yaml-cpp 0.5取消了运算符&quot;&amp;gt;&amp;gt;&quot;，但是还是会有好多的旧代码
{
  i = node.as&amp;lt;T&amp;gt;();                              //依旧在使用，所以重载下&quot;&amp;gt;&amp;gt;&quot;运算符
}
void configure(const YAML::Node&amp;amp; node);
void nodePrint(const YAML::Node&amp;amp; node);
int main()
{
  YAML::Node config = YAML::LoadFile(&quot;../monsters.yaml&quot;);  
  configure(config[&quot;Ladybug&quot;]);
  return 0;
}
void configure(const YAML::Node&amp;amp; node)
{
  std::cout &amp;lt;&amp;lt; &quot;node size is &quot; &amp;lt;&amp;lt; node.size() &amp;lt;&amp;lt; std::endl;
  for (unsigned int i = 0; i &amp;lt; node.size(); i++)
  {
    nodePrint(node[i]);
  }
}
void nodePrint(const YAML::Node&amp;amp; node)
{
  int name;
  int topic;
  string timeout;
  double priority;
  node[&quot;showImage&quot;]       &amp;gt;&amp;gt; name;
  node[&quot;saveImage&quot;]      &amp;gt;&amp;gt; topic;
  node[&quot;savePath&quot;]    &amp;gt;&amp;gt; timeout;
  node[&quot;resize&quot;]   &amp;gt;&amp;gt; priority;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;yaml文件&quot;&gt;yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# yaml for ladybug and rcs
Ladybug:
  - showImage:   1
    saveImage:   1
    savePath:    &quot;../filename&quot;
    resize:      1.0
    truncateBottom:    0.1
    truncateTop:    0.1
DetectArea:
  - radius:      6.0
    speed:       2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;写yaml文件&quot;&gt;写yaml文件&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginSeq;
out &amp;lt;&amp;lt; &quot;eggs&quot;;
out &amp;lt;&amp;lt; &quot;bread&quot;;
out &amp;lt;&amp;lt; &quot;milk&quot;;
out &amp;lt;&amp;lt; YAML::EndSeq;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- eggs
- bread
- milk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;=========================&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginMap;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;name&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;Ryan Braun&quot;;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;position&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;LF&quot;;
out &amp;lt;&amp;lt; YAML::EndMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name: Ryan Braun
position: LF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;=========================&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;YAML::Emitter out;
out &amp;lt;&amp;lt; YAML::BeginMap;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;name&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; &quot;Barack Obama&quot;;
out &amp;lt;&amp;lt; YAML::Key &amp;lt;&amp;lt; &quot;children&quot;;
out &amp;lt;&amp;lt; YAML::Value &amp;lt;&amp;lt; YAML::BeginSeq &amp;lt;&amp;lt; &quot;Sasha&quot; &amp;lt;&amp;lt; &quot;Malia&quot; &amp;lt;&amp;lt; YAML::EndSeq;
out &amp;lt;&amp;lt; YAML::EndMap;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name: Barack Obama
children:
  - Sasha
  - Malia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;==========================&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/08/26/yaml-cpp/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/08/26/yaml-cpp/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Miscellaneous杂记</title>
        <description>&lt;h2 id=&quot;小岛经济学&quot;&gt;小岛经济学&lt;/h2&gt;

&lt;p&gt;没有自由的失败，就没有自由的成功&lt;/p&gt;

&lt;h2 id=&quot;effective-modern-c&quot;&gt;Effective Modern C++&lt;/h2&gt;

&lt;p&gt;It’s been said that the truth shall set you free, but under the right circumstances, a well-chose lie can be equally liberating. We comprise “lie” to abstraction.&lt;/p&gt;

&lt;p&gt;Bear in mind that the truth doesn’t make the abstraction any less useful.&lt;/p&gt;

&lt;p&gt;In short, rvalue reference should be &lt;em&gt;unconditionally&lt;/em&gt; cast to rvalue (via &lt;strong&gt;std::move&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Universal refenrence should be &lt;em&gt;conditionally&lt;/em&gt; cast to rvalue (via &lt;strong&gt;std::forward&lt;/strong&gt;).&lt;/p&gt;

&lt;h2 id=&quot;外汇管理局新规2016&quot;&gt;外汇管理局新规2016&lt;/h2&gt;

&lt;p&gt;根据外管局最新规定：&lt;a href=&quot;https://xueqiu.com/5514474822/66337756&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;5个以上不同个人，同日、隔日或连续多日分别购汇后，将外汇汇给境外同一个人或机构；&lt;/li&gt;
  &lt;li&gt;个人在7日内从同一外汇储蓄账户5次以上提取接近等值1万美元外币现钞；&lt;/li&gt;
  &lt;li&gt;同一个人将其外汇储蓄账户内存款划转至5个以上直系亲属等情况。
将被界定为个人分拆结售汇行为，也就是俗称的“蚂蚁搬家”，一律进入黑名单，违规者将被剥夺两年合计10万美元的换汇额度。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;活着&quot;&gt;活着&lt;/h2&gt;

&lt;p&gt;内心使他真正地了解自己，了解了自己也就了解了世界。&lt;/p&gt;

&lt;h2 id=&quot;海盗经济学&quot;&gt;海盗经济学&lt;/h2&gt;

&lt;p&gt;海盗船实行的是民主（democracy），而商船实行的是专制（autocracy）；在海盗船上，甚至黑人（18th century)也能够享受和白人一样的权利，很少出现像商船那样，船长侮辱甚至殴打船员的现像，而且无论船长还是舵手和普通船员的工资差不多，没有商船上的差别那么悬殊。归结原因其实是&lt;em&gt;所有制&lt;/em&gt;导致了二者实行不同的管理制度，不同的管理制度保证了二者都有最大的总体利益，只是相对个人而言不甚相同。&lt;/p&gt;

&lt;h2 id=&quot;精通数据科学&quot;&gt;精通数据科学&lt;/h2&gt;
&lt;p&gt;The purpose of computing is insight, not numbers.
If you are immune to boredom, there is literally nothing you cannot accomplish. – David Foster Wallace&lt;/p&gt;

&lt;h2 id=&quot;effective-c&quot;&gt;Effective C++&lt;/h2&gt;
&lt;p&gt;I have not been able to find a convincing explanation. But the rule is the rule, and this means you must
remember that if you declare a variable using auto and you initialize it with a braced initializer, the deduced type will always be std::initializer_list. It’s especially important to bear this in mind if you embrace the philosophy of uniform initialization—of enclosing initializing values in braces &lt;strong&gt;as a matter of course(理所当然)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;It provides results that leave you scratching your head and turning to reference works or online Q&amp;amp;A sites for revelation.&lt;/p&gt;

&lt;p&gt;What may initially seem contradictory (decltype and auto?) actually makes perfect sense.&lt;/p&gt;

&lt;p&gt;Employing pass-by value for objects of &lt;strong&gt;an unknown type&lt;/strong&gt; generally risks the performance hit of unnecessary
copying, the behavioral problems of object slicing, and the sting of our coworkers’ derision.&lt;/p&gt;

&lt;p&gt;bring it into accord with admonition 使之符合告诫&lt;/p&gt;

&lt;p&gt;You’ll have to familiarize yourself with a few special cases. Most of these are too obscure to warrant discussion in a book like this, but looking at one lends insight into decltype as well as its use.&lt;/p&gt;

&lt;p&gt;At the same time, don’t lose sight of the bigger picture.&lt;/p&gt;

&lt;p&gt;I do my best to convice you to use lambdas instead of std::bind.&lt;/p&gt;

&lt;p&gt;Take a deep breath and relax. auto is a option, not a mandate.&lt;/p&gt;

&lt;p&gt;such abstract type information should almost always be at hand.&lt;/p&gt;

&lt;p&gt;nullptr shines especially brightly when templates enter the picture.&lt;/p&gt;

&lt;p&gt;There’s a historical reason for that, but we’ll skip over it (it’s dull, I promise)&lt;/p&gt;

&lt;p&gt;Examples will clarify what I mean:&lt;/p&gt;

&lt;p&gt;In many cases, you may decide that typing a few extra characters is a reasonable price to pay for the ability to avoid the pitfalls of an enum technology that dates to a time when the state of the art in digital telecommunications was the 2400-baud modem.&lt;/p&gt;

&lt;p&gt;This is hardly the most encapsulated design that’s seen the light of day.&lt;/p&gt;

&lt;p&gt;There’s some wiggle room for optimization through what is known as the “as if rule,” but you’d be foolish
to rely on your compilers finding a way to take advantage of it.&lt;/p&gt;

&lt;p&gt;Don’t let the warm glow of this happy ending distract you from the true point of this Item&lt;/p&gt;

&lt;p&gt;Restrictions are imposed on their implementations.&lt;/p&gt;

&lt;p&gt;Have endured my endless blathering about the rules governing the copy and move operations in C++11.&lt;/p&gt;

&lt;p&gt;Don’t worry if you see something whose motivation is less than obvious.&lt;/p&gt;

&lt;p&gt;They don’t hinder callers from replacing it with its more flexible sibling.&lt;/p&gt;

&lt;p&gt;How primitive!&lt;/p&gt;

&lt;p&gt;Unleash your search engine.&lt;/p&gt;

&lt;p&gt;No divorce, no annulment, no dispensations.&lt;/p&gt;

&lt;p&gt;The more experience you have with these features, the more you realize that your initial impression was based on only the metaphorical tip of the proverbial iceberg.&lt;/p&gt;

&lt;p&gt;No matter how far you dig into these features, it can seem that there’s always more to uncover. Fortunately, there is a limit to their depths. This chapter will take you to the bedrock.&lt;/p&gt;

&lt;p&gt;It’s been said that the truth shall set you free, but under the right circumstances, a well-chosen lie can be equally liberating.&lt;/p&gt;

&lt;p&gt;My liberal use of quotation marks should tip you off that this line of reasoning is flawed.&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/27/miscellaneous/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/27/miscellaneous/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>C++ 11/14/17</title>
        <description>&lt;h2 id=&quot;c-111417关键字&quot;&gt;C++ 11//14/17关键字&lt;/h2&gt;

&lt;h3 id=&quot;using关键字&quot;&gt;using关键字&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，但是对函数指针等别名的定义语法却不相同。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int (*process)(void*);
using process = int(*)(void *);

using TrueDarkMagic = MagicType&amp;lt;std::vector&amp;lt;T&amp;gt;, std::string&amp;gt;;
TrueDarkMagic&amp;lt;bool&amp;gt; you;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 using 引入了继承构造函数的概念：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BASE{
		public:
				int value1;
				int value2;
				BASE(){
						value1 = 1;
				}
				BASE(int value): BASE(){ //委托BASE()构造函数
						value2 = 2;
				}
};
class subBASE: public BASE{
		using BASE:BASE; //继承构造
};

int main(){
		subBASE s(3);
		std::cout &amp;lt;&amp;lt; s.value1&amp;lt;&amp;lt;s.value2&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;c111417标准库&quot;&gt;C++11/14/17标准库&lt;/h2&gt;

&lt;h3 id=&quot;stdarray&quot;&gt;std::array&lt;/h3&gt;

&lt;p&gt;std::array 保存在栈内存中，std::vector保存在堆内存。&lt;/p&gt;

&lt;p&gt;std::array 会在编译时创建一个固定大小的数组，std::array 不能够被&lt;em&gt;隐式&lt;/em&gt;的转换成指针。&lt;/p&gt;

&lt;p&gt;使用 std::array 很简单，只需指定其类型和大小即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::array&amp;lt;int, 4&amp;gt; arr= {1,2,3,4};
int len = 4;
std::array&amp;lt;int, len&amp;gt; arr = {1,2,3,4}; // *非法*, 数组大小参数必须是常量表达式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与C风格接口传参&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void foo(int *p, int len) {
    return;
}
std::array&amp;lt;int, 4&amp;gt; arr = {1,2,3,4}; //实例

// C 风格接口传参
// foo(arr, arr.size()); // *非法*, 无法隐式转换
foo(&amp;amp;arr[0], arr.size());
foo(arr.data(), arr.size()); //arr.data() return 指向arr的指针
// 使用 `std::sort`
std::sort(arr.begin(), arr.end());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;智能指针&quot;&gt;智能指针&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;智能指针实质是一个对象，行为表现的却像一个指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;引用计数不是垃圾回收，引用技术能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，更能够清晰明确的表明资源的生命周期。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 &lt;memory&gt;。&lt;/memory&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而无需显示得调用 delete，当引用计数变为零的时候就会将对象自动删除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;shared_ptr and unique_ptr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单个unique_ptr离开作用域时，会立即释放底层内存，既然是独占，换句话说就是不可复制;可以有多个shared_ptr实例指向同一块动态分配的内存，当最后一个shared_ptr离开作用域时，才会释放这块内存.&lt;/p&gt;

&lt;h3 id=&quot;c中正则表达式&quot;&gt;C++中正则表达式&lt;/h3&gt;

&lt;p&gt;正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查一个串是否包含某种形式的子串；&lt;/li&gt;
  &lt;li&gt;将匹配的子串替换；&lt;/li&gt;
  &lt;li&gt;从某个串中取出符合条件的子串。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;| &lt;strong&gt;特殊字符&lt;/strong&gt;  | &lt;strong&gt;描述&lt;/strong&gt; |
| :— | :—-: |
| $ | 匹配输入字符串的结尾位置 |
| (,) | 标记一个子表达式的开始和结束位置 |
|* | 匹配前面的子表达式零次或多次。
|+  | 匹配前面的子表达式一次或多次。
|. | 匹配除换行符 \n 之外的任何单字符。
————————————————–&lt;/p&gt;

&lt;h2 id=&quot;线程与并发&quot;&gt;线程与并发&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;最简单的是使用std::thread创建一个线程实例，这是并发编程的基础，需要包含&lt;thread&gt;头文件，其提供很多基本的线程操作：&lt;/thread&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;get_id()&lt;/em&gt; required ID of the created thead.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;join()&lt;/em&gt;  add one thread to pool.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
void foo()
{
    std::cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; std::endl;
}
int main()
{
    std::thread t(foo); //new one thread
    t.join(); //start the thread, the main funtion waits until the thread ends
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::mutex is the basic class in C++11, mutex variables can be created via instancing std::mutex. &lt;mutex&gt; needs to be included.&lt;/mutex&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;member funtion: lock() unlock()&lt;/p&gt;

&lt;p&gt;object: std::unique_lock&lt;std::mutex&gt; std::look_guard&lt;std::mutex&gt;&lt;/std::mutex&gt;&lt;/std::mutex&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;mutex&amp;gt;
std::mutex mtx;
void block_area() {
std::unique_lock&amp;lt;std::mutex&amp;gt; lock(mtx);
    //...临界区
lock.unlock();
    //...some other code
lock.lock(); //  can lock again
}
int main() {
    std::thread thd1(block_area);
    std::thread thd2(block_area);
    thd1.join(); //阻塞式，main等待线程接受后一并返回
    thd2.detach(); //放在后台执行，与main无关了
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::future, std::packaged_task&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;std::future提供了一个访问异步操作结果的途径，是一种简单的线程同步手段。&lt;/p&gt;

&lt;p&gt;std::packaged_task用来封装任何可以调用的目标，从而实现异步调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;future&amp;gt;
#include &amp;lt;thread&amp;gt;
int main()
{
    // 将一个返回值为7的 lambda 表达式封装到 task 中
    // std::packaged_task 的模板参数为要封装函数的类型
    std::packaged_task&amp;lt;int()&amp;gt; task([](){return 7;});
    // 获得 task 的 future
    std::future&amp;lt;int&amp;gt; result = task.get_future(); // 在一个线程中执行 task
    std::thread(std::move(task)).detach(); std::cout &amp;lt;&amp;lt; &quot;Waiting...&quot;;
    result.wait();
    // 输出执行结果
    std::cout &amp;lt;&amp;lt; &quot;Done!&quot; &amp;lt;&amp;lt; std:: endl &amp;lt;&amp;lt; &quot;Result is &quot; &amp;lt;&amp;lt; result.get() &amp;lt;&amp;lt; '\n';
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;std::condition_variable&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。condition_variable 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。&lt;/p&gt;

&lt;h2 id=&quot;参数包&quot;&gt;参数包&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;模板参数包&lt;/strong&gt;是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数模板形参报是接受零或更多函数实参的函数形参。&lt;/p&gt;

&lt;p&gt;参考的链接：&lt;a href=&quot;https://www.cnblogs.com/qicosmos/p/4325949.html&quot;&gt;泛化之美&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至少有一个参数包的模板被称作&lt;strong&gt;变参数模板&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下面这种情况是&lt;em&gt;类模板&lt;/em&gt;（变参数类模板可用任意数量的模板参数实例化）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;class ... Types&amp;gt; struct Tuple {};
Tuple&amp;lt;&amp;gt; t0;           // Types 不包含实参
Tuple&amp;lt;int&amp;gt; t1;        // Types 包含一个实参： int
Tuple&amp;lt;int, float&amp;gt; t2; // Types 包含二个实参： int 与 float
Tuple&amp;lt;0&amp;gt; error;       // 错误： 0 不是类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面这种情况是&lt;em&gt;函数模板&lt;/em&gt;(变参数函数模板可用任意数量的函数实参调用{&lt;strong&gt;模板参数通过模板实参推导推导&lt;/strong&gt;}）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;class ... Types&amp;gt; void f(Types ... args);
f();       // OK ： args 不包含实参
f(1);      // OK ： args 包含一个实参： int
f(2, 1.0); // OK ： args 包含二个实参： int 与 double
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在初等类模板中，模板参数包必须是模板形参列表的最后一个形参。所以这是错误的&lt;code class=&quot;highlighter-rouge&quot;&gt;template&amp;lt;typename... Ts, typename U&amp;gt; struct Invalid;&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Ts.. 应该放在结尾&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在函数模板中，模板参数包可以在列表中早于所有能从函数实参推导的参数出现，或拥有默认参数。所以：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename ...Ts, typename U, typename=void&amp;gt;
void valid(U, Ts...);     // OK ：能推导 U
// void valid(Ts..., U);  // 不能使用： Ts... 在此位置是非推导语境
valid(1.0, 1, 2, 3);      // OK ：推导 U 为 double ， Ts 为 {int,int,int}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;右值引用&quot;&gt;右值引用&lt;/h2&gt;

&lt;p&gt;为了解决：第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。&lt;/p&gt;

&lt;p&gt;区分左值和右值：能不能对表达式取地址，如果能，则为左值，否则为右值&lt;/p&gt;

&lt;p&gt;非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = getVar(); // i是左值
T&amp;amp;&amp;amp; k = getVar(); // getVar()产生的临时值不会像第一行代码那样，在表达式结束之后就销毁了，而是会被“续命”。
                  // 他的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int g_constructCount=0;
struct{
  A(){
        cout&amp;lt;&amp;lt;&quot;construct: &quot;&amp;lt;&amp;lt;++g_constructCount&amp;lt;&amp;lt;endl;    
     }
};
A GetA()
{
    return A();
}
int main(){
  A a = GetA(); //需要生成临时对象，而后销毁临时对象
  const A&amp;amp; a = GetA(); // 与下面这句一样，少了一次拷贝和析构
  A&amp;amp;&amp;amp; a = GetA(); //少了一次拷贝和析构
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过右值引用，比之前少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。我们可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构。&lt;/p&gt;

&lt;p&gt;常量左值引用是一个“万能”的引用类型，可以接受左值、右值、常量左值和常量右值。需要注意的是普通的左值引用不能接受右值，比如这样的写法是不对的：&lt;code class=&quot;highlighter-rouge&quot;&gt;A&amp;amp; a = GetA();&lt;/code&gt;。但是右值引用独立于左值和右值，意思是右值引用类型的变量可能是左值也可能是右值，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;T&amp;amp;&amp;amp; t&lt;/code&gt;在&lt;strong&gt;发生自动类型推断&lt;/strong&gt;的时候(一般都是模板的T&amp;amp;&amp;amp;)，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。&lt;/p&gt;

&lt;p&gt;变量1 = 函数()–&amp;gt;返回值：这时出现函数返回一个临时变量，拷贝给变量1，一般此时要求返回值、变量的复制构造函数完成深拷贝，否则可能发生指针悬挂的问题，但是可以设置复制构造函数为&lt;code class=&quot;highlighter-rouge&quot;&gt;A(A&amp;amp;&amp;amp; a) :m_ptr(a.m_ptr)&lt;/code&gt;，这时只完成浅拷贝（移动构造，实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;std::move&lt;/code&gt;实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用），即函数返回的右值直接付给了变量1，由于右值没有内存地址，所以不会发生指针悬挂的问题；以前的方式可以采用这样&lt;code class=&quot;highlighter-rouge&quot;&gt;A(const A&amp;amp; a):m_ptr(new int(*a.m_ptr))&lt;/code&gt;完成深拷贝复制构造。&lt;/p&gt;

&lt;h2 id=&quot;完美转发&quot;&gt;完美转发&lt;/h2&gt;

&lt;p&gt;C++11引入了完美转发：在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中的std::forward正是做这个事情的，他会按照参数的实际类型进行转发。&lt;/p&gt;

&lt;p&gt;最后给出一个使用完美转发的泛型模板：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename…  Args&amp;gt;
T* Instance(Args&amp;amp;&amp;amp;… args)
{
    return new T(std::forward&amp;lt;Args &amp;gt;(args)…);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/20/cpp-11-14-17/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/20/cpp-11-14-17/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Grid Map developed by ETHz</title>
        <description>&lt;h2 id=&quot;grid-map-can-contain-multiple-map-layers&quot;&gt;Grid map can contain multiple map layers&lt;/h2&gt;

&lt;p&gt;The following map is constructed with one layer called “elevation”.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace grid_map;
GridMap map({&quot;elevation&quot;});
for (GridMapIterator it(map); !it.isPastEnd(); ++it){
  Position position;
  map.getPosition(*it, position);
  map.at(&quot;elevation&quot;, *it) = -0.04 + 0.2 * std::sin(3.0 * time.toSec() + 5.0 * position.y()) * position.x();
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 03 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/07/03/ethz-grid-map/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/07/03/ethz-grid-map/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Real-time Control System</title>
        <description>&lt;p&gt;&lt;strong&gt;千万不要以rcs-test等短划线的方式命名RCS工程&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rcs-structure&quot;&gt;RCS Structure&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;{project-name}.nml //配置buffer文件，使用#注释&lt;/li&gt;
  &lt;li&gt;{project-name}svr.cc //server源文件，编译后变为可执行文件&lt;/li&gt;
  &lt;li&gt;{project-name}main.cc //main程序，其中定义了module对象，并循环执行module中的××_process()&lt;/li&gt;
  &lt;li&gt;{module-name}_module.cc // 模块代码，工程的功能模块&lt;/li&gt;
  &lt;li&gt;{module-name}.hh // 对应上面的module.cc，是它的头文件&lt;/li&gt;
  &lt;li&gt;{module-name}n.hh //模块的status和command通道&lt;/li&gt;
  &lt;li&gt;{aux-channel}n.hh //工程的辅助通道&lt;/li&gt;
  &lt;li&gt;GNUmakefile // makefile文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rcs-config&quot;&gt;RCS Config&lt;/h2&gt;

&lt;p&gt;RCS中主要的配置都在.nml文件中，nml文件可以分为三部分：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;buffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;module-name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;srv&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果使用的buffer不是该工程的srv建立的，但该工程使用了这个buffer，那么在buffer和module-name部分都要声明这个buffer，但&lt;strong&gt;srv&lt;/strong&gt;部分没有这个buffer，对应&lt;strong&gt;{project-name}svr.cc&lt;/strong&gt;中也没有关于该buffer的构建的code。
{Note} 该工程的nml文件中buffer部分声明的使用的buffer需要和定义该buffer的（srv申请的buffer）工程中的buffer MP必须相同，TCP貌似也应该相同。&lt;/p&gt;

&lt;h2 id=&quot;rcs-module&quot;&gt;RCS Module&lt;/h2&gt;

&lt;p&gt;在声明辅助通道时候，如果该module是input该辅助通道，那么一般会这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//&amp;lt;module-name&amp;gt;.hh
NML * ×××_CHANNEL;//
×××_MSG * ×××_data;//这是一个指针
//&amp;lt;module-name&amp;gt;_module.cc
×××_CHANNEL = new NML(×××Format, &quot;&amp;lt;buffer-name&amp;gt;&quot;, &quot;&amp;lt;moudle-name&amp;gt;&quot;, &quot;×××.nml&quot;);
×××_data = (×××_MSG *) ×××_CHANNEL-&amp;gt;get_address();
switch(SLAMPOSAZIM_CHANNEL-&amp;gt;read())
{
  case ×××_MSG_TYPE:
          do-someting....;
	break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果该module是output该辅助通道，那么一般会这样写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NML * ×××_CHANNEL;//
×××_MSG ×××_data;//这是一个对象
×××_CHANNEL = new NML(×××Format, &quot;&amp;lt;buffer-name&amp;gt;&quot;, &quot;&amp;lt;moudle-name&amp;gt;&quot;, &quot;×××.nml&quot;);
...赋值操作。。。
×××_CHANNEL-&amp;gt;write(&amp;amp;×××_data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;命令通道&quot;&gt;命令通道&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h2 id=&quot;两个文件夹在一台电脑上共用一个辅助通道&quot;&gt;两个文件夹在一台电脑上共用一个辅助通道&lt;/h2&gt;

&lt;p&gt;nml配置：对于这个通道的而言，其buffer number/MP/TCP port保持一致，否则diag_NB.jar会报错。&lt;/p&gt;

&lt;h2 id=&quot;diag_nbjar&quot;&gt;diag_NB.jar&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -jar /usr/local/diag_NB.jar
在对话框里open **.cfg
这个过程需要打开cfg文件中提到的channel的P_**n.hh，否则diag_NB无法确定channel的类型
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改nml文件注意事项&quot;&gt;修改nml文件注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在nml文件中增加删除某个buffer，注意更改相应的××svr.cc中的该buffer对应的channel相关代码&lt;/li&gt;
  &lt;li&gt;由codegen.jar将{aux_channel}n.hh得到的{aux_channel}n_n.cc中会自动生成一个关于该通道最小是多少数值，供参考。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;rcs-struct类型的声明&quot;&gt;RCS struct类型的声明&lt;/h2&gt;

&lt;p&gt;DECLARE_NML_DYNAMIC_LENGTH_ARRAY({类型名}, 数组变量名, 数组的最大长度);//声明一个数组&lt;/p&gt;

&lt;p&gt;在某个{aux_channel}n.hh中需要声明一个struct{结构体};，需要在该文件中同时声明&lt;code class=&quot;highlighter-rouge&quot;&gt;extern void nmlupdate(CMS *cms, {结构体名称} *x);&lt;/code&gt;，这将通过codegen产生结构体的构造函数&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/06/29/realtimecontrolsystem/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/06/29/realtimecontrolsystem/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
      <item>
        <title>Leetcode</title>
        <description>&lt;h2 id=&quot;euler-and-quaternion&quot;&gt;Euler and Quaternion&lt;/h2&gt;

&lt;h3 id=&quot;from-euler-to-quaternion&quot;&gt;From Euler to Quaternion:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using namespace Eigen;
//Roll pitch and yaw in Radians
float roll = 1.5707, pitch = 0, yaw = 0.707;    
Quaternionf q;
q = AngleAxisf(roll, Vector3f::UnitX())
    * AngleAxisf(pitch, Vector3f::UnitY())
    * AngleAxisf(yaw, Vector3f::UnitZ());
std::cout &amp;lt;&amp;lt; &quot;Quaternion&quot; &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; q.coeffs() &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;from-quaternion-to-euler&quot;&gt;From Quaternion to Euler:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto euler = q.toRotationMatrix().eulerAngles (0, 1, 2);
std::cout &amp;lt;&amp;lt; &quot;Euler from quaternion in roll, pitch, yaw&quot;&amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; euler &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;use-eigenisometry3d-pose-to-describe-translation-and-rotation&quot;&gt;Use Eigen::Isometry3d pose to describe translation and rotation&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::Isometry3d pose; //4 by 4 matrix in fact
pose.linear() = q.normalized().toRotationMatrix();
pose(0,3) = pos_x;
pose(1,3) = pos_y;
pose(2,3) = pos_z;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;an-affine-transformation-to-an-isometric-transformation&quot;&gt;an affine transformation to an isometric transformation&lt;/h2&gt;

&lt;p&gt;b.rotation() extract the rotation part of the transformation. It involves a SVD, and thus it is read-only. On the left hand side, you have to use .linear():&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Eigen::AffineCompact3f a;
Eigen::Isometry3f b;
b.translation() = a.translation();
b.linear() = a.rotation();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you know that ‘a’ is an isometry and only want to cast it to an Isometry 3f, you can simply do:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;b = a.matrix();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 13 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/blog/2018/06/13/laser-process/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2018/06/13/laser-process/</guid>
        
        <category>技术总结</category>
        
        
        <category>blog</category>
        
      </item>
    
  </channel>
</rss>
