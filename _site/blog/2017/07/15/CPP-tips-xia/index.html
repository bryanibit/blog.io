<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="于华超">

    <title>C++ textbook 下 - 屋顶上的鱼</title>

    <link rel="canonical" href="http://bryanibit/blog/2017/07/15/CPP-tips-xia/">

    <!-- Icons -->
  <link rel="shortcut icon" href="img/favicon.ico">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>



<link rel="shortcut icon" type="image/png" href="img/favicon.png">
</link>

<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">屋顶上的鱼</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
                <li>
                    <a href="/about/">About</a>
                </li>
                
                <li>
                    <a href="/archive/">Archive</a>
                </li>
                
                <li>
                    <a href="/milestone/">milestone</a>
                </li>
                
                <li>
                    <a href="/tags/">Tags</a>
                </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/black.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="Tags">
                        
                        <a class="tag" href="/Tags/#理论梳理" title="理论梳理">理论梳理</a>
                        
                    </div>
                    <h1>C++ textbook 下</h1>
                    
                    <span class="meta">Posted by Bryan on July 15, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>




<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container">

                <p><strong>一下部分高能预警，请细心体会（本书第8~12章）今天看完前10章</strong></p>
<h2 id="8类和队象">8.类和队象</h2>
<ul>
  <li>任何对象都应该有两个要素：属性（静态特征）/行为（动态特征）,由数据和函数两部分组成</li>
  <li>对象在设计时，考虑封装特性，将外部行为和内部行为分隔开，同时将各个对象之间的相对独立</li>
  <li>对象是具体存在的，类是对象的抽象，对象是类的特例</li>
  <li>多态指：由继承而产生的相关不同的类，其对象对同一消息会作不同反应</li>
</ul>

<p><strong>程序=对象s+消息</strong></p>

<h4 id="类和结构体的区别">类和结构体的区别</h4>
<ul>
  <li>首先你可以将类声明时使用的class关键字换成struct，这是完全成立的</li>
  <li>struct未做声明时，默认成员为public这是和class不同的地方</li>
  <li>当类的某成员函数大于3行时，可以将声明放在类内，定义移到类外，使整个类看起来更加清楚</li>
  <li>类的对象的存储空间：共有函数存储空间，自身的存储空间存储成员变量
    <div class="highlighter-rouge"><pre class="highlight"><code>class Time
{public:
 int hour;
 int minute;
 private:
 int show_times();
};//这些放在time.h头文件中
int Time::show_times()
{}
//这些放在time.cpp源文件中
Time t, *p;
p=&amp;t;
cout&lt;&lt;p-&gt;hour;
cout&lt;&lt;t.minute;
cout&lt;&lt;endl;//这些放在main中
</code></pre>
    </div>
    <h2 id="9类和对象的进一步讨论">9.类和对象的进一步讨论</h2>
  </li>
</ul>

<h3 id="91-构造函数">9.1 构造函数</h3>

<ul>
  <li>用户根据<strong>初始化</strong>的要求设计函数体和函数参数，这就是构造函数</li>
  <li>构造函数与类同名，在声明对象时自动执行构造函数，构造函数没有返回类型，因而也没有类型
       构造函数名（类型1形参1， 类型2形参2）
    <h4 id="911-用参数初始化表对数据成员初始化">9.1.1 用参数初始化表对数据成员初始化</h4>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Box{Box(int,int, int);
int height;
int width;
int length;}
Box::Box(int h,int w, int len):height(h),width(w),length(len){}
</code></pre>
    </div>
    <h4 id="构造函数重载">构造函数重载</h4>
    <p>以下声明两个Box()</p>
    <div class="highlighter-rouge"><pre class="highlight"><code>class Box{Box(int,int, int);
Box();
int height;
int width;
int length;}
Box::Box()
{
 height = 10;
 width = 10;
 length = 10;
}
Box::Box(int h,int w, int len):height(h),width(w),length(len){}
</code></pre>
    </div>
    <h4 id="构造函数的默认参数">构造函数的默认参数</h4>
  </li>
  <li>Box(int h=10,int w=10, int len=10); 这是声明，在类内部，具体定义在类外边
这相当于好多个重载函数的作用</li>
</ul>

<h4 id="说明">说明</h4>
<ul>
  <li>调用构造函数时，不必给出实参的构造函数称为默认构造函数，或叫缺省构造函数</li>
  <li>构造对象的写法为Box box2; 不是 Box box2();这是声明函数的返回值为类Box</li>
  <li>构造函数的重载在函数声明的时候就要确定，具体定义的时候没有默认参数值，和普通的默认参数函数声明定义相同</li>
  <li>一个类只能同时有一个构造函数有效：Box();Box(int=10,int =10, int =10);同时存在二者是错误的</li>
</ul>

<h3 id="92-析构函数">9.2 析构函数</h3>

<ul>
  <li>static局部对象在main结束后才被析构；用new运算符动态建立的对象，当用delete运算符释放该对象是，先调用该对象的析构函数</li>
  <li>析构函数的<strong>作用</strong>不是删除对象，而是撤销对象占用的内存之前完成一些清理工作，使这部分内存可以分配给新对象使用</li>
  <li>析构函数不能重载，你想重载啥！</li>
  <li>析构函数也可写一些最后想说的话，在对象即将销毁之前
    <h3 id="93-对象指针">9.3 对象指针</h3>
  </li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>类的成员变量
int *p1;
p1 = &amp;t1.hour;
cout&lt;&lt; *p1&lt;&lt;endl;
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>普通函数
void (*p)(int, int);//指向void型函数的指针变量
p = fun;
(*p)(int a,int b)//调用fun函数
</code></pre>
</div>
<div class="highlighter-rouge"><pre class="highlight"><code>类的成员函数
void (Time::*p2)();
p2=Time::get_time;
(t1.*p2)();//调用t1中的p2所指函数
</code></pre>
</div>
<ul>
  <li>一个类多个对象，成员函数对应相同的代码段，以上赋值指针变量p2的应该是公用的函数代码段的入口地址
以上两句定义和指定指针指向合并为
    <div class="highlighter-rouge"><pre class="highlight"><code>void (Time::*p2)()=Time::get_time;
</code></pre>
    </div>
  </li>
  <li>函数的指针变量的类型必须与赋值号右侧函数类型在以下3个方面匹配：</li>
  <li>1.函数参数的类型和参数个数 2.函数返回值的类型 3.所属的类</li>
</ul>

<h3 id="94-this指针">9.4 this指针</h3>

<ul>
  <li>如果一个类对应多个对象，存放多个对象的数据成员，但是不同的对象都调用同一个函数代码段</li>
  <li>不同对象的成员函数引用数据成员时，保证引用的是所指定的对象的数据成员</li>
  <li>每个<em>成员函数</em>都包含一个特殊的指针，成为this，它指向<em>本类对象</em>的指针，它的值是<em>当前被调用的成员函数所在的对象的起始地址</em>
    <div class="highlighter-rouge"><pre class="highlight"><code>对象指针
Time *p;
Time t1;
p=&amp;t1;
</code></pre>
    </div>
  </li>
  <li>用new运算符动态分配内存后返回一个指向<em>新对象的指针的值</em>,就是所<em>分配的内存空间的起始地址</em>
    <div class="highlighter-rouge"><pre class="highlight"><code>Box *pt;
pt=new Box;
</code></pre>
    </div>
  </li>
  <li>以上方法新建了一个对象可以使用以下方法来访问
    <div class="highlighter-rouge"><pre class="highlight"><code>pt-&gt;height;
</code></pre>
    </div>
    <p>合成一句话并初始化</p>
  </li>
  <li>Box *pt = new Box(12,15,18); //构造函数</li>
</ul>

<h4 id="对象的赋值">对象的赋值</h4>

<p>对象名1 = 对象名2</p>

<p>box1 = box2;</p>

<h4 id="对象的复制">对象的复制</h4>

<p>类型 对象2（对象1）</p>

<p>Box box2(box1);</p>

<p>Box box2 = box1;</p>

<h3 id="95-类的静态成员">9.5 类的静态成员</h3>

<ul>
  <li>静态成员变量不隶属于任何一个对象，它是类的成员，即使不定义对象，静态数据成员也被分配空间，也可被引用</li>
  <li>静态成员变量不随对象的撤销而释放，它是类的成员。</li>
  <li>静态成员变量只能在类外进行初始化
    <div class="highlighter-rouge"><pre class="highlight"><code>int Box::height = 10;//height is static variable of class Box
</code></pre>
    </div>
  </li>
  <li>初始化（构造函数）中不能操作静态变量
    <div class="highlighter-rouge"><pre class="highlight"><code>Box b = new Box();
b.height;//可以使用对象名访问静态成员
</code></pre>
    </div>
    <h4 id="类的静态函数">类的静态函数</h4>
  </li>
  <li>静态函数存在的价值主要是操作静态变量</li>
  <li>静态函数是类的而不是对象的成员，所以它没有this指针，所以无法访问本类中的非静态成员</li>
  <li>因为</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>
int Box::volume()
{
	return (height\*width\*length);
}

change to the following

int Box::volume(Box *this)
{
	return (this-&gt;height\*this-&gt;width\*this-&gt;length);
}
</code></pre>
</div>

<ul>
  <li>由于静态变量没有this指针，找不到内存中当前需要操作的成员变量</li>
  <li>Therefore, 保证静态函数只操作静态变量，当然也可以操作非静态，只有在对静态变量时，才显得最简介易懂</li>
</ul>

<h3 id="96-友元">9.6 友元</h3>

<ul>
  <li>不属于类，但是放在在类的声明，不就像是一个不是家人的friend正在家里开party吗～</li>
  <li>友元存在的价值在于虽可以不属于本类，但作为其友元，可以访问其的私有成员变量；友元函数实现多个类的数据共享；</li>
  <li>下面的程序展示了Date中的友元函数由Time中的成员函数担任，使之能访问两个类的成员，注意访问的方式</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>class Date;//对Date类的提前引用声明
class Time
{
public: Time(int, int, int);
		void display(Date &amp;);
private:int hour;
		int minute;
		int sec;
};
Time::Time(int a, int b, int c)
{
	hour = a;
	minute = b;
	sec = c;
}

class Date
{
public:Date(int, int, int);
	  friend void Time::display(Date &amp;);
private:int month;
		int day;
		int year;
};
Date::Date(int a, int b, int c)
{
	month = a;
	day = b;
	year = c;
}

void Time::display(Date &amp;d)//对Date对象的引用
{
	cout &lt;&lt; d.day &lt;&lt; ":" &lt;&lt; d.month &lt;&lt; ":" &lt;&lt; d.year &lt;&lt; endl;//访问私有成员
	cout &lt;&lt; hour &lt;&lt; ":" &lt;&lt; minute &lt;&lt; ":" &lt;&lt; sec &lt;&lt; endl;
}

int main()
{
	Time t1(10, 13, 56);
	Date d1(12, 25, 2004);
	t1.display(d1);
	return 0;
}
</code></pre>
</div>

<ul>
  <li>下面的程序，友元函数不是类的成员函数，通过重载访问两个类的私有数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>class Time
{
public: Time(int, int, int);
		friend void display(Time &amp;);
private:int hour;
		int minute;
		int sec;
};
Time::Time(int a, int b, int c)
{
	hour = a;
	minute = b;
	sec = c;
}
class Date
{
public:Date(int, int, int);
	  friend void display(Date &amp;);
private:int month;
		int day;
		int year;
};
Date::Date(int a, int b, int c)
{
	month = a;
	day = b;
	year = c;
}
void display(Date &amp; d)
{
	cout &lt;&lt; d.day &lt;&lt; "/" &lt;&lt; d.month &lt;&lt; "/" &lt;&lt; d.year &lt;&lt; endl;
}
void display(Time &amp; t)
{
	cout &lt;&lt; t.hour &lt;&lt; "/" &lt;&lt; t.minute &lt;&lt; "/" &lt;&lt; t.sec &lt;&lt; endl;
}
int main()
{
	Time t1(10, 13, 56);
	Date d1(12, 25, 2004);
	display(d1);
	display(t1);
	return 0;
}
</code></pre>
</div>

<p>##10.运算符重载</p>

<h3 id="101-重载的方法">10.1 重载的方法</h3>

<ul>
  <li>函数类型 operator 运算符名称 （形参表列）</li>
  <li>{对运算符的重载处理}
e.g.
int operator + (int a, int b)</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>class Complex
{public:Complex(){real=0;img=0;}
Comlex(double a, double b){real=a;img=b}
Complex operator + (Complex &amp;);
private:double real;
double img;};

Complex Complex::operator + (Complex &amp;c2)
{return Complex(c2.real+this-&gt;real,c2.img+img);// 直接返回一个无名对象
}
int main()
{Complex c1(1.2,3.4);
Complex c2(13.5,3.4);
Complex c = c1+c2;//c = c1.operator+(c2)
}
</code></pre>
</div>

<p>不能重载的运算符有5个:</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>.</td>
          <td>.*</td>
          <td>::</td>
          <td>sizeof</td>
          <td>?:</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>重载不改变运算符优先级，重载运算符参数必须至少包含一个用户自定义的类或struct，否则就失去了重载运算符的意义，而且发生错误。
<strong>一般情况：双目运算符重载为类的友元函数，单目运算符重载为类的成员函数</strong>
以上代码段修改为friend表示为</p>
<div class="highlighter-rouge"><pre class="highlight"><code>class Complex
{public:Complex(){real=0;img=0;}
Comlex(double a, double b){real=a;img=b}
friend Complex operator + (Complex &amp;, Complex &amp;);
private:double real;
double img;};

Complex Complex::operator + (Complex c1,Complex &amp;c2)
{return Complex(c2.real+c1.real,c2.img+c1.img);// 直接返回一个无名对象
}
int main()
{Complex c1(1.2,3.4);
Complex c2(13.5,3.4);
Complex c = c1+c2;//c = c1.operator+(c2)
}
</code></pre>
</div>
<h3 id="重载流运算符">重载流运算符</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>istream &amp; operator &gt;&gt; (istream &amp;, 自定义类 &amp;);
ostream &amp; operator &lt;&lt; (ostream &amp;, 自定义类 &amp;);
</code></pre>
</div>
<p>重载流运算符函数必须作为友元函数不能作为类的成员函数，原因显而易见，位置已经被stream &amp;占据</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Complex
{public:Complex(){real=0;img=0;}
Comlex(double a, double b){real=a;img=b}
friend ostream operator &lt;&lt; (ostream &amp;, Complex &amp;);
friend istream operator &gt;&gt; (istream &amp;, Complex &amp;);
private:double real;
double img;};

friend ostream operator &lt;&lt; (ostream &amp; os, Complex &amp; c)
{return os&lt;&lt;c.real&lt;&lt;" + "&lt;&lt;c.img&lt;&lt;"i"&lt;&lt;endl;
}
friend istream operator &gt;&gt; (istream &amp; is, Complex &amp; c)
{return is&gt;&gt;c.real&gt;&gt;c.img;
}
int main()
{Complex c1;
Complex c2;
cin&gt;&gt;c2&gt;&gt;c1;//手动输入4个数字
cout&lt;&lt;c1&lt;&lt;c2;//(cout&lt;&lt;c1)return ostream所以可以继续&lt;&lt;c2
}
</code></pre>
</div>

<h3 id="构造函数as强制类型转换">构造函数as强制类型转换</h3>

<p>构造函数复习（revise）
默认构造函数</p>
<ul>
  <li>Complex()</li>
  <li>Complex(double, double);</li>
  <li>Complex(Comlex &amp;);//e.g.在类成员函数的声明体中声明一个表示自身的对象 Complex temp(*this),最后return temp，将本身返回</li>
</ul>

<p>Complex(double r){real=r;img=0;}</p>

<p>Complex(2.5) 比较 int(2.5)</p>
<ul>
  <li>可以认为二者都是进行了强制类型转换</li>
  <li>c=c1+int(2.5) false; c=c1+Complex(2.5) true</li>
</ul>

<h3 id="类型转换函数进行类型转换">类型转换函数进行类型转换</h3>

<p>类型转换函数作用是将一个类对象转换成另一个类型的数据，在Complex类中定义类型转换函数：</p>
<div class="highlighter-rouge"><pre class="highlight"><code>operator double()
 {return real;}
</code></pre>
</div>
<ul>
  <li>抽象一般形式为
<code class="highlighter-rouge">operator 类型名()
 {实现转换的语句}</code>
<em>在函数名前面不能指定函数类型，而且函数没有参数</em></li>
</ul>

<h2 id="11继承与派生">11.继承与派生</h2>

<p>C++继承可以增加代码可重用性，继承主要学会使用protected</p>

<p>一个派生类有两个或多个基类的称为多重继承</p>

<p><strong>class 派生类名：继承方式 基类名</strong>
<strong>{派生类新增加的成员}；</strong></p>

<p>构建一个派生类包括以下3部分工作：</p>
<ol>
  <li>从基类接收其全部成员</li>
  <li>调整从基类接收的成员：声明一个参数和函数名和函数返回值类型都相同的函数覆盖原来基类的函数</li>
  <li>声明派生类时增加成员</li>
</ol>

<h3 id="111成员的访问属性">11.1成员的访问属性</h3>

<p>基类和派生类的访问属性</p>

<p>公有继承/私有继承/保护继承，基类的私有成员仍然是私有的，公有和保护成员<em>近似</em>变为继承的类型</p>

<p>不能通过派生类<strong>对象</strong>引用从私有基类继承的任何成员，只能通过派生类成员函数引用私有基类的公有和保护成员。</p>

<p>继承是对基类公有和保护成员的继承，基类的私有成员只能被基类的成员函数调用。</p>

<ul>
  <li>保护成员相当于保险箱，任何外人均不得窥视，只有子女（派生类）才能打开</li>
</ul>

<p>在派生类中有4中不同的访问属性：</p>
<ul>
  <li>公用的：派生类内外都可以访问</li>
  <li>受保护的：对于本类同私有的，其下一层的派生类可以访问</li>
  <li>私有的：派生类内可以访问，外不可</li>
  <li>不可访问的：派生类内和外都无法访问
<strong>总结</strong> 保护（protected)是专门为派生设计的访问权限，基类的保护成员对于本类是私有的，对于保护继承的派生类可以类内访问，不可类外调用（派生类对象访问），这是因为它仍然是‘保护’访问权限，对于本类（派生类）是私有的。</li>
</ul>

<p><strong>在实际使用中，常用的是公有继承</strong></p>

<h3 id="112-派生类的构造函数和析构函数">11.2 派生类的构造函数和析构函数</h3>

<p>基类的构造函数是不能继承的，所以要初始化派生类对象应该同时考虑基类的对象，方法是执行派生类构造函数时，调用基类的构造函数。e.g.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Student(int n,string nam,char s){}//基类构造函数，放在基类中
Student_derivedclass(int n,string name, char s, int a, string ad):Student(n,nam,s){}
//本句放在派生类中作为派生类的构造函数
</code></pre>
</div>

<h3 id="113-有子对象的派生类的构造函数">11.3 有子对象的派生类的构造函数</h3>

<p>类定义中含有类的对象，就像结构体中含有结构体</p>
<ul>
  <li>子对象的初始化是在建立派生类时通过调用派生类构造函数实现的
定义派生类构造函数的一般形式为
<strong>派生类构造函数名（总参数列表）：基类构造函数名（参数表列），子对象名（参数表列）</strong>
<strong>{派生类中新增数据成员初始化语句}</strong>
下面是一个例子，monitor是子对象，是基类的对象
```
class Student
{public:
 Student(int n, string nam)
 {num = n;
name=nam;}
 protected:
 int num; string name;
};</li>
</ul>

<p>class Student1: public Student
{public:
 Student1(int n, string nam, int n1, string nam1, int a, string ad):Student(n,nam),monitor(n1,nam1)
{age = a;
 addr = ad;}//构造函数
private:
 Student monitor;//派生类子对象
 int age;
 string addr;
```</p>
<h3 id="114-虚基类">11.4 虚基类</h3>



                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/blog/2017/07/14/OpenSfM-understand/" data-toggle="tooltip" data-placement="top" title="OpenSfM opensource textbook">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/blog/2017/07/18/ROS-tutorial/" data-toggle="tooltip" data-placement="top" title="ROS tutorials">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- Duoshuo Share start -->
                <style>
                    .ds-share{
                        text-align: right;
                    }

                    @media only screen and (max-width: 700px) {
                        .ds-share {

                        }
                    }
                </style>

                <div class="ds-share"
                    data-thread-key="/blog/2017/07/15/CPP-tips-xia" data-title="C++ textbook 下"
                    data-images="http://bryanibit/img/black.jpg"
                    data-content="一下部分高能预警，请细心体会（本书第8~12章）今天看完前10章
8.类和队象

  任何对象都应该有两个要素：属性（静态特征）/行为（动态特征）,由数据... | Microdust:Azeril's blog"
                    data-url="http://bryanibit/blog/2017/07/15/CPP-tips-xia/">
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">

                        <!-- <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li> -->
                         <!-- <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>-->
                        <!-- <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li> -->
                        <!-- <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li> -->
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- Duoshuo Share end-->


                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread" data-thread-key="/blog/2017/07/15/CPP-tips-xia" data-title="C++ textbook 下" data-url="http://bryanibit/blog/2017/07/15/CPP-tips-xia/"></div>
                </div>
                <!-- 多说评论框 end -->
            </div>
        </div>
    </div>
</article>


<!-- mathjax script -->
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"cnfeat"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <!-- kill the Facebook and Weibo -->
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    

                    
                    
                    <!--
                    
                    -->

                    <!--
                    
                    -->

                    
                    <!--
                    
                    -->

                </ul>
                <p class="copyright text-muted">
                &copy; 2017  Bryan ❖ Powered by Jekyll.
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>



<!-- Highlight.js -->
<script>
    async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js",function(){
        hljs.initHighlightingOnLoad();
    })
</script>
<link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">


</body>

</html>
