---
layout: post
title: Git Push Suggestion
date: 2017-8-22
categories: blog
tags: [技术总结]
description: git usage
---

## 在github新建分支安全操作

Doing carefully is better than fixing after errors happen

```
git checkout -b <branch_name>  新建分支并将当前分支带到新建分支,git branch <branch_name>和git checkout <branch_name>
git add -A
git commit -m "×××××"
git push
git push --set-upstream origin <branch_name>   push到新建分支上
git checkout master      check到master分支
git merge <branch_name>   合并修改 <branch_name>和master指向同一个修改，merge后的修改，如果冲突需要手工修改
git branch -d test     删除本地分支
git push origin --delete <branch_name>   删除远程分支(github)上的分支
```

## windows中git配置代理

git config --global http.proxy http://127.0.0.1:8087

git config --global https.proxy https://127.0.0.1:8087

使用https链接
git remote add origin https://github.com/username/××.git

## 版本回退

- [ ] Just modify file in working directory but not add to temporary directory

```
git checkout -- <filename> // undo modified
git clean -xdf // delete new files
```

- [ ] Add to temporary directory but not commit

```
//unstage modification，如果是全部文件使用 . 符号；使用--代替HEAD，对于没有commit的仓库
git reset HEAD <filename>
git checkout -- <filename>
```

- [ ] Commit finished

```
git log
git reset --hard HEAD^
```

## 保存当前分支修改

使用下面的命令可以在不commit当前分支的基础上，切换到另外一个分支

```
git stash
```

切回主分支（stash所在分支），然后键入```git stash pop```

## 将当前在master下的修改push到dev分支上

```
git stash // Hide away your changes (basically making a temporary commit),
git checkout {another-branch}
git pop // Pop re-applies them
```

如果整个work tree都乱了，那就

```
# Unstage everything (warning: this leaves files with conflicts in your tree)
git reset
# Add the things you *do* want to commit here _manually_ using gedit or vim
git add -p     # or maybe git add -i
git commit
```

如果只是某几个文件无法自动merge，那就

```
git checkout -- <filename1>
# Add the things you *do* want to commit here _manually_ with gedit or vim
git add -p     # or maybe git add -i
git commit
```

由于original-branch分支还没有处理，现在切回原来分支：
```
# The stash still exists; pop only throws it away if it applied cleanly
git checkout original-branch
git stash pop
# Add the changes meant for this branch
git add -p
git commit
# And throw away the rest
git reset --hard
```

## Git Submodule

用于两个独立的git目录，其中一个用到了另外一个。二者可以是同级的关系，也可以是父子目录的关系。(You want to be able to treat the two projects as separate yet still be able to use one from within the other.This lets you clone another repository into your project and keep your commits separate.)


## git push and merge local branch

> When push.default is set to 'matching', git will push local branches to
> the remote branches that already exist with the same name.

当 push.default 的值设置成 ‘matching’ ，git 将会推送所有本地已存在的同名分支到远程仓库

从 Git 2.0 开始，git 采用更加保守的值'simple'，只会推送当前分支到相应的远程仓库，'git pull' 也将值更新当前分支。

```
git config --global push.default simple //同步当前分支
git config --global push.default matching //同步与当前工作区相同名称的所有分支
```

## git删除远程或本地分支

Deleting a remote branch:

```
git push origin --delete <branch>  # Git version 1.7.0 or newer
git push origin :<branch>          # Git versions older than 1.7.0
```

Deleting a local branch:

```
git branch --delete <branch>
git branch -d <branch> # Shorter version
git branch -D <branch> # Force delete un-merged branches
```

## Git Submodule

If your project contains other libraries which you never or seldom modify, you should adopt **submodule** to manage your project. And if one of subdirectories is independent to others, which means the subdirectory is special or distinguished, such as *communication message* subdirectory, you could employ that to it.  

### add submodule from remote to your local

```
✗ git submodule add git@github.com:bryanibit/DGPS.git  
Cloning into 'DGPS'...
remote: Enumerating objects: 41, done.
remote: Total 41 (delta 0), reused 0 (delta 0), pack-reused 41
Receiving objects: 100% (41/41), 154.02 KiB | 123.00 KiB/s, done.
Resolving deltas: 100% (2/2), done.
Checking connectivity... done.
✗ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DGPS
```
You should notice the new ```.gitmodules``` file. This is a configuration file that stores the mapping between the project’s URL and the local subdirectory you’ve pulled it into:
```
[submodule "DGPS"]
	path = DGPS
	url = git@github.com:bryanibit/DGPS.git
```
At last, we can use ```git push origin master``` to push new dir including submodules to remote.

### Cloning a Project with Submodules

```
git submodule init
git submodule update
```
Initialize your local configuration file and fetch all the data from that project. Another way is to pass ```--recurse-submodules``` to the *git clone* command, it will automatically **initialize and update** each submodule in the repository.
```
git clone --recurse-submodules git@github.com:bryanibit/DGPS.git
```

### Synchronize submodule with remote

```
cd submodule
git fetch
git merge origin/master
--------another way--------
git pull
```
There is another way to synchronize the project(easy to cause **detached HEAD(HEAD points commit ID)**):
```
# just update DGPS submodule
git submodule update --remote DGPS # outside submode, in main project
cd DGPS
git status # HEAD detached at fc01c3d
```
When we’ve run the ```git submodule update``` command to fetch changes from the submodule repositories, Git would get the changes and update the files in the subdirectory but will leave the sub-repository in what’s called a **detached HEAD** state. This means that there is no local working branch (like “master”, for example) tracking changes. With no working branch tracking changes, that means even if you *commit changes to the submodule*, those changes will quite possibly be lost the next time you run *git submodule update*. You have to do some extra steps if you want changes in a submodule to be tracked.  

In order to set up your submodule to be easier to go in and hack on, you need to do two things. You need to go into each submodule and check out a branch to work on. The options are that you can merge them into your local work, or you can try to rebase your local work on top of the new changes.  
```
git checkout stable
git submodule update --remote --merge
```
The foregoing commands means that you should create a new branch to save your modifications if you want to modify submodules. If not, those changes will be lost the next time running *git submodule update*.  

## push changes in submodules

```
$ git push --recurse-submodules=check
The “check” option will make push simply fail
if any of the committed submodule changes
haven’t been pushed. It is deployed after
git push each submodule.
$ git push --recurse-submodules=on-demand
Git went into the DGPS module and pushed it
before pushing the main project. If that
submodule push fails for some reason,
the main project push will also fail.
$ git push
In each submodule and main project
```
The last but not least, you can revise and push DGPS in its project and cd the big(parent) project to use git submodule update --remote

## Workflow for integration

The workflow for integrating a package is as follows:  
1. The official code repository is in the github (known as official tree).
2. Each team has a corresponding repository in the github (known as team repository)
3. The code to integrate should be in the local git repository
4. The code has to be pushed to the team repository in the github and a pull request has to be opened to integrator.
5. Jenkins server is then activated:
6. Pull the code
7. Compile it.
8. Perform sanity tests
9. Integrator then pull the new code and makes its own checks: functionality, bugs correction, integration
10. Issues are opened and tracked via trac server
11. If the new code is good enough, it is pushed to the official tree.
