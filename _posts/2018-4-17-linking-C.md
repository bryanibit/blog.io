---
layout: post
title: 链接 Link
date: 2018-4-17
categories: blog
tags: [技术总结]
description: 计算机基本内容之链接
---

## 静态链接

ld是静态链接器，可重定位目标文件由代码段和数据节组成。链接器ld主要完成：**符号解析**和**重定位**。符号解析就是将符号引用与符号定义联系起来，重定位是符号定义与存储器位置联系起来。

## 目标文件

分为三种：可重定位目标文件（.o），可执行文件，共享文件（.so/.dll）。

## 可重定位目标文件

其有很多类型，以ELF (Executable and Linkable Format)为例，其文件结构为

ELF header、节和描述节的节头部表，每个节都有固定大小的entry（条目），不同节的位置与大小由节头部表确定。

典型的ELF文件中，

```
ELF头
.text:编译的代码
.rodata:只读数据，比如printf中的string
.data:初始化的全局变量
.bss:未初始化的全局变量，只是占位符，所以better save space
.symtab:符号表，存放定义和引用的函数与全局变量信息
.rel.text
.rel.data 重定位条目
.strtab:字符串表，其内容包含.symtab中的符号表，以及节头部中的节名称。字符串表实际上是以null结尾的字符串
等等
```

注意：这里局部变量存在程序运行的栈中，不在重定位目标文件中。

## 符号和符号表

符号表（在.symtab中）中有三种类型符号

* 没有static的全局变量或函数
* 带有static的本地变量或函数
* 其他模块定义，本模块引用的全局变量或函数

注意：不包含任何局部变量，但是如果局部变量带有static修饰，则在.data中存储而不在栈中存储。

### ELF符号表条目

对于main.c swap.c而言，使用

```
gcc -s main.c swap.c
```
得到main.o swap.o

```
readelf -a main.o
```
可以查看符号表条目，其中value表示该符号相对于所属节的偏移，size是大小，bind表示全局还是本地，这里没有局部变量，Ndx表示所属字段，包括ABS(不该被重定位的符号), UNDEF(未定义的符号，例如extern修饰的变量), COMMON(为初始化的变量，将来变为.bss中的内容), 1(.text), 3(.data)

## 符号解析

连接器解析  符号引用<=>符号定义 联系起来

最后编译器中每个模块中每个本地符号只有一个定义，拥有唯一的名字。

对于全局变量的引用解析相对复杂：如果一个全局变量在当前模块中没有，则假设符号是在其他模块中定义的，生成一个链接器符号表条目，链接器在其他模块中寻找。

### 全局符号的多重定义

对于链接器，需要处理全局符号的多重定义，在编译时，编译器（得到汇编语言文件.s）向汇编器（得到可定位重定向文件.o，之后对.o操作的是ld链接）输出的每个符号，有**强**/**弱**之分，而汇编器将这写到可重定位目标文件中：函数与初始化的全局变量是强，未初始化的全局变量是弱符号。

同时规定 1. 不能有多个强符号（所以定义多个同名函数时，编译出错）； 2. 有强和弱多个符号，选强的； 3. 有弱符号多个，随机选。

## 下面开始说链接的事情

### 与静态库链接

```
Unix> gcc main.c /usr/lib/libc.o
```

如此，libc.o将和main.c链接成同一个可执行文件，将libc.o中的文件整个copy，大小很大。

静态库中相关函数编译为独立的目标模块，然后封装为一个单独的静态库文件。如下

```
Unix> gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```

链接器只拷贝被程序引用的目标模块，这样减少了可执行文件的大小。

更具体一点：将两个可重定位目标文件链接为一个静态库（本身静态库就是一种称为存档【archive】的特殊文件格式，存档文件由一组链接起来的可重定位目标文件集合而成）

```
Unix> gcc -c addvec.c multvec.c
unix> ar rcs libvetcor.a addvec.o multvec.o
```

如果main函数只调用了addvec.c中定义的函数，而没有调用multvec.c中定义的函数，链接器运行时将只拷贝addvec.o到生成的可执行文件中，不引用multvec.o的内容。


## 重定位

在完成符号解析后，可以进行重定位。在这步骤中，将合并输入模块，并未每个符号分配运行时地址。**重定位可以分为两步**：

1. 重定位节和符号定义

合并同一类型的节，例如合成.data节为一个节，这个节为输出的可执行文件的.data节。

2. 重定位节的符号引用

链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行地址，这依赖于重定位条目

### 重定位条目

汇编器对最终位置未知的目标引用，会生成一个重定位条目，告诉链接器（下一步）在讲目标文件合并为可执行文件时，如何修改这个引用

代码的重定位条目放在.rel.text中，已初始化的重定位条目在.rel.data中。

### 加载可执行目标文件

Linux运行时存储器映像：在32位系统中，代码段（只读段 .text .rodata）总是从地址0x0804 8000处开始，数据段（读/写段 .data,.bss）从接下来的下一个4KB对齐的地址处。

运行时堆在读/写段之后接下来的第一个4KB对齐的地址处，并通过调用malloc库往上动态增长。

用户栈总是从最大的合法用户地址开始往下（低地址）增长，栈的上部开始的段是为操作系统留的存储器部分（内核的代码和数据）。

在用户栈和运行时堆之间的某个区域保留为动态库的存储器映射区域。

可执行目标文件与可重定位目标文件结构类似，如下图：

```
ELF头
*段头部表*
*.init*
.text:编译的代码
.rodata:只读数据，比如printf中的string
.data:初始化的全局变量
.bss:未初始化的全局变量，只是占位符，所以better save space
.symtab:符号表，存放定义和引用的函数与全局变量信息
.strtab:字符串表，其内容包含.symtab中的符号表，以及节头部中的节名称。字符串表实际上是以null结尾的字符串
*节头表*
等等
```

ELF头部描述文件的总体格式，包括程序的入口点，也就是程序运行时执行的第一条指令地址。

.text, .rodata, .data与可重定位目标文件相似，只是已经被重定位到最终运行时的存储器地址。

.init节定义了一个小函数，叫_init，程序的初始化代码会调用它。

因为可执行文件时**完全链接的（已经被重定位）** ， 所以不需要重定位，故没有.rel节。

段头部表描述了可执行文件连续的片（chunk）银蛇到连续的存储器段的这种映射关系。

### 动态链接共享库

使用命令
```ldd liborb.so```

可以查看动态库链接了的其他库目录

## 从应用程序中
